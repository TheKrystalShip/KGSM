#!/usr/bin/env bash

# This file is autogenerated
#
# Modifications done to this file will only affect this game server instance.
# Any changes made to this file will be overwritten if the file is regenerated.
# KGSM will not regenerated this file on its own, but there is a command that
# can be manually used to regenerate the file in case something breaks:
# > $KGSM_ROOT/modules/files.sh --instance <instance> --create --manage

debug=
# shellcheck disable=SC2199
if [[ $@ =~ "--debug" ]]; then
  debug=" --debug"
  export PS4='+(\033[0;33m${BASH_SOURCE}:${LINENO}\033[0m): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  set -x
  for a; do
    shift
    case $a in
    --debug) continue ;;
    *) set -- "$@" "$a" ;;
    esac
  done
fi

# === BEGIN INJECT CONFIG ===
# === END INJECT CONFIG ===

self=$(basename "$0")

function usage() {
  echo "
Usage:
  $self OPTION

Options:
  -h, --help                Display this help message
  --start                   Start the server in the current terminal
  --start [--background]    Start the server in the background
  --stop                    Stop the server
  --is-active               Prints if the server is active
  --input <command>         Send an ad-hoc command to the server
  --logs                    Print last 10 lines of the log
  --logs [-f, --follow]     Read live logs
  --enable-upnp             Enable UPnP ports
  --disable-upnp            Disable UPnP ports

  --download                Downloads the game server files
  --download [version]      Downloads the game server files for a specific version
  --deploy                  Deploys the game server files from the temporary directory
  --update                  Updates the game server files to the latest version

  --list-backups            Print a list of available backups
  --create-backup           Create a backup of the game server files
  --restore-backup <source> Restore a specified backup

  --version                 Print the locally installed version
  --version [--save <ver>]  Save a given version to file
  --version [--latest]      Print the latest available version
  --version [--compare]     Test the local version vs the latest available.

Examples:
  $self --start --background
  $self --input '/save'
  $self --stop
"
}

SUCCESS="SUCCESS"
INFO="INFO"
ERROR="ERROR"
WARNING="WARNING"

## Colored output
# Check if stdout is tty
if test -t 1; then
  ncolors=0

  # Check for availability of tput
  if command -v tput >/dev/null 2>&1; then
    ncolors="$(tput colors)"
  fi

  # More than 8 means it supports colors
  if [[ $ncolors ]] && [[ "$ncolors" -gt 8 ]]; then
    WARNING="${COLOR_ORANGE}${WARNING}${COLOR_END}"
  fi
fi

function __print_success() {
  echo -e "[$SUCCESS] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1"
}

function __print_info() {
  echo -e "[$INFO] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1"
}

function __print_error() {
  echo -e "[$ERROR] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1" >&2
}

function __print_warning() {
  echo -e "[$WARNING] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1" >&2
}

# shellcheck disable=SC2199
if [[ $@ =~ "--debug" ]]; then
  export PS4='+(\033[0;33m${BASH_SOURCE}:${LINENO}\033[0m): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  set -x
  for a; do
    shift
    case $a in
    --debug) continue ;;
    *) set -- "$@" "$a" ;;
    esac
  done
fi

set -o pipefail

if [[ $# -eq 0 ]]; then
  __print_error "Missing arguments"
  exit 1
fi

function _enable_upnp() {
  local output

  __print_info "Enabling UPnP..."

  if ! output=$(upnpc -e "$instance_name" -r "${instance_upnp_ports[@]}" 2>&1); then
    __print_error "Failed to enable UPnP ports"
    __print_info "To stop these message, set 'enable_port_forwarding' to 0 in $0"
    __print_error "${output}"
  fi

  __print_success "UPnP enabled"
}

function _disable_upnp() {
  local output

  __print_info "Disabling UPnP..."

  if ! output=$(upnpc -f "${instance_upnp_ports[@]}" 2>&1); then
    __print_error "Failed to disable UPnP ports"
    __print_info "To stop these message, set 'instance_enable_port_forwarding' to 'false' in $0"
    __print_error "${output}"
  fi

  __print_success "UPnP disabled"
}

# Cleanup function for SIGINT, SIGTERM, and EXIT
function _term_cleanup() {
  [[ "${instance_enable_port_forwarding:-false}" == "true" ]] && _disable_upnp
  _exit_print_logs
}

# Make sure to disable UPnP if it was enabled
# This is done to prevent leaving UPnP ports open
# when the script is interrupted
trap '_term_cleanup' INT TERM EXIT

# Start the server in the current terminal
function _start() {
  __print_info "Starting server in foreground..."

  if [[ "$instance_enable_port_forwarding" == "true" ]]; then
    _enable_upnp
  fi

  if [[ "$instance_auto_update" == "true" ]]; then
    _update
  fi

  # Use docker compose up to start the container with logs visible
  # Change to working directory first to ensure docker-compose.yml is found
  (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" up)
}

# Start the server in the background
function _start_background() {
  __print_info "Starting server in background..."

  if [[ "$instance_enable_port_forwarding" == "true" ]]; then
    _enable_upnp
  fi

  # Use docker compose up -d to start the container in detached mode
  # Change to working directory first to ensure docker-compose.yml is found
  (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" up -d)

  __print_success "Server started in background"
}

function _send_save_command() {
  __print_info "Saving game state..."
  # For Docker containers, this may not do anything unless the game has a specific save command
  # that can be sent to the container
  return 0
}

function _send_input() {
  local command=$1
  __print_info "Sending command: $command"

  # Check if the container is running using the existing _is_active function
  if ! _is_active &>/dev/null; then
    __print_error "Container '$instance_name' is not running"
    return 1
  fi

  # Get the management file path from the container's environment
  local management_file
  management_file=$(docker exec "$instance_name" bash -c 'echo $MANAGEMENT_FILE')

  if [[ -z "$management_file" ]]; then
    __print_error "Could not determine management script path in container. \$MANAGEMENT_FILE not set."
    return 1
  fi

  # Call the container's internal management script with the --input flag
  if ! docker exec -i "$instance_name" "$management_file" --input "$command"; then
    __print_error "Failed to send command to container '$instance_name'"
    return 1
  fi

  __print_success "Command sent to container"
  return 0
}

function _is_active() {
  # Check if the container is running using docker compose
  # Run in the working directory where docker-compose.yml is located
  cd "$instance_working_dir" || {
    __print_error "Failed to change to working directory: $instance_working_dir"
    return 1
  }

  if docker compose -f "$instance_compose_file" ps --services --filter "status=running" | grep -q .; then
    __print_info "Active"
    return 0
  fi

  __print_info "Inactive"
  return 1
}

function _print_logs() {
  local follow=$1

  if [[ "$follow" == "--follow" ]]; then
    (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" logs -f) &
    tail_pid=$!
    wait "$tail_pid"
  else
    (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" logs --tail=10)
  fi
}

function _stop_server() {
  local no_save=$1
  local no_graceful=$2

  __print_info "Stopping server..."

  if ! _is_active &>/dev/null; then
    __print_warning "Instance $instance_name is not running"
    return 0
  fi

  # Save game if requested
  if [[ "$no_save" != "true" ]]; then
    _send_save_command
  fi

  if [[ "$instance_enable_port_forwarding" == "true" ]]; then
    _disable_upnp
  fi

  # Use docker compose down to stop the container
  # Run in the working directory where docker-compose.yml is located
  (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" down)

  __print_success "Instance $instance_name stopped"
  return 0
}

function _update() {
  __print_info "Updating Docker container..."

  # For container instances, updating means:
  # 1. Pull the latest images defined in the docker-compose file
  # 2. Recreate the containers with the latest images

  # Pull the latest images - run in the working directory
  (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" pull)

  # If the container is running, stop it and recreate
  if _is_active &>/dev/null; then
    (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" up -d --force-recreate)
  else
    # Just recreate without starting
    (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" up -d)
    (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" down)
  fi

  # Call the management script with the --update flag inside the container
  (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" run --rm --update)

  # Update version information
  echo "latest" >"$instance_version_file"

  __print_success "Update complete"
  return 0
}

function _create_backup() {
  __print_info "Creating backup of Docker container data..."

  local datetime="$(date +"%Y-%m-%dT%H:%M:%S")"
  local output="${instance_backups_dir:-$instance_working_dir/backups}/${instance_name}-${datetime}.backup.tar.gz"

  # Create backups directory if it doesn't exist
  mkdir -p "$(dirname "$output")"

  # Make sure the container is stopped before backing up
  if _is_active &>/dev/null; then
    _stop_server
  fi

  # Create a tar.gz of the entire working directory
  tar -czf "$output" -C "$instance_working_dir" .

  __print_success "Backup created: $output"
  return 0
}

function _restore_backup() {
  local backup="$1"
  local backups_dir="${instance_backups_dir:-$instance_working_dir/backups}"
  local source="$backups_dir/$backup"

  __print_info "Restoring backup from $source..."

  if [[ ! -f "$source" ]]; then
    __print_error "Backup file not found: $source"
    return 1
  fi

  # Stop the container if it's running
  if _is_active &>/dev/null; then
    _stop_server
  fi

  # Extract the backup to the working directory
  tar -xzf "$source" -C "$instance_working_dir"

  __print_success "Backup restored from $source"
  return 0
}

function _list_backups() {
  # List all backup files in the backups directory
  local backups_dir="${instance_backups_dir:-$instance_working_dir/backups}"

  if [[ ! -d "$backups_dir" ]]; then
    __print_warning "No backups directory found at: $backups_dir"
    return 0
  fi

  # Check if there are any backups
  if [[ -z "$(ls -A "$backups_dir" 2>/dev/null)" ]]; then
    __print_info "No backups found in $backups_dir"
    return 0
  fi

  __print_info "Available backups:"
  ls -1 "$backups_dir"
}

function _get_installed_version() {
  if [[ -f "$instance_version_file" ]]; then
    cat "$instance_version_file"
  else
    echo "latest"
  fi
}

function _get_latest_version() {
  # For containers, we can use the Docker image tag or digest
  # This example uses the 'latest' tag, but could be modified to check for
  # updated images using Docker Hub API or other methods
  echo "latest"
}

function _compare_versions() {
  # For Docker containers, comparing versions is less relevant
  # since we're working with images and not actual game files
  # We can pull the latest image and check if it's different
  echo "latest"
  return 1 # Return non-zero to indicate no update needed
}

function _save_version() {
  local version=$1

  __print_info "Saving version ${version}..."

  echo "$version" >"$instance_version_file"

  __print_success "Version saved"
  return 0
}

function _download() {
  local version="${1:-latest}"

  __print_info "Downloading Docker image version ${version}..."

  # For container-based instances, downloading means pulling the images
  # defined in the compose file
  # This will pull all images defined in the docker-compose.yml file
  # Run in the working directory where docker-compose.yml is located
  (cd "$instance_working_dir" && docker compose -f "$instance_compose_file" pull)

  __print_success "Download complete"
  return 0
}

function _deploy() {
  # For Docker containers, deploying is a noop
  # since the container is already defined in the docker-compose.yml file
  __print_info "Deploying Docker container..."

  # Return success
  __print_success "Deploy complete"
  return 0
}

# Check if docker and docker-compose are installed
if ! command -v docker &>/dev/null; then
  __print_error "Docker is not installed. Please install Docker to use this script."
  exit 1
fi

if ! command -v docker compose &>/dev/null; then
  __print_error "Docker Compose is not installed. Please install Docker Compose to use this script."
  exit 1
fi

# Main execution starts here - process command line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
  -h | --help)
    usage && exit 0
    ;;
  --start)
    shift
    if [[ -z "$1" ]]; then
      _start
      exit $?
    fi
    case "$1" in
    --background)
      _start_background
      exit $?
      ;;
    *)
      __print_error "Invalid argument $1"
      exit 1
      ;;
    esac
    ;;
  --stop)
    shift
    no_save=false
    no_graceful=false
    while [[ $# -gt 0 ]]; do
      case "$1" in
      --no-save)
        no_save=true
        shift
        ;;
      --no-graceful)
        no_graceful=true
        shift
        ;;
      *)
        break
        ;;
      esac
    done
    _stop_server "$no_save" "$no_graceful"
    exit $?
    ;;
  --save)
    _send_save_command
    exit $?
    ;;
  --is-active)
    _is_active
    exit $?
    ;;
  --input)
    shift
    [[ -z "$1" ]] && __print_error "Missing argument <command>" && exit 1
    _send_input "$1"
    exit $?
    ;;
  --logs)
    shift
    follow=""
    if [[ -n "$1" ]] && [[ "$1" == "-f" || "$1" == "--follow" ]]; then
      follow="--follow"
    fi
    _print_logs "$follow"
    exit $?
    ;;
  --enable-upnp)
    _enable_upnp
    exit $?
    ;;
  --disable-upnp)
    _disable_upnp
    exit $?
    ;;
  --version)
    shift
    if [[ -z "$1" ]]; then
      _get_installed_version
      exit $?
    fi
    case "$1" in
    --compare)
      _compare_versions
      exit $?
      ;;
    --latest)
      _get_latest_version
      exit $?
      ;;
    --save)
      shift
      if [[ -z "$1" ]]; then
        __print_error "Missing argument <version>"
        exit 1
      fi
      _save_version "$1"
      exit $?
      ;;
    *)
      __print_error "Invalid argument $1"
      exit 1
      ;;
    esac
    ;;
  --download)
    shift
    version=
    if [[ -n "$1" && "$1" != --* ]]; then
      version="$1"
    fi
    _download "$version"
    exit $?
    ;;
  --deploy)
    _deploy
    exit $?
    ;;
  --update)
    _update
    exit $?
    ;;
  --create-backup)
    _create_backup
    exit $?
    ;;
  --restore-backup)
    shift
    if [[ -z "$1" ]]; then
      __print_error "Missing argument <backup>"
      exit 1
    fi
    _restore_backup "$1"
    exit $?
    ;;
  --list-backups)
    _list_backups
    exit $?
    ;;
  *)
    __print_error "Unknown argument $1"
    exit 1
    ;;
  esac
  shift
done

exit 0
