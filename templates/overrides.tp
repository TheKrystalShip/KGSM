#!/usr/bin/env bash

################################################################################
#                          KGSM FUNCTION OVERRIDE FILE                         #
################################################################################
# This file allows you to implement custom functions that will replace the
# default functions in the generated management script for your game server.
#
# Customize game-specific behavior without modifying KGSM core files.
#
################################################################################
#
# HOW TO USE THIS FILE:
# 1. Uncomment and implement only the specific functions you need to override
# 2. Keep the function names exactly the same
# 3. Implement your custom logic inside each function
# 4. Save this file as <blueprint-name>.overrides.sh in the overrides/ directory
#
################################################################################
#
# IMPORTANT GUIDELINES:
# - Only uncomment and implement the functions you need to override
# - Default implementations will be used for any function not defined here
# - Ensure proper error handling and return codes in your implementations
# - Use the provided logging functions to maintain consistent output format
# - Test your overrides thoroughly before deploying to production
#
################################################################################
#
# AVAILABLE GLOBAL VARIABLES:
#
# COMMON SERVER VARIABLES:
# instance_name                 Name of the instance
# instance_working_dir          Working directory for the instance
# instance_install_dir          Directory where the server is installed
# instance_launch_dir           Directory from which to launch server (may differ from install dir)
# instance_saves_dir            Directory for save files
# instance_temp_dir             Temporary directory for downloads/processing
# instance_backups_dir          Directory for backups
# instance_logs_dir             Directory for logs
# instance_socket_file          Path to the socket file for communication
# instance_pid_file             Path to the PID file to track server process
# instance_version_file         Path to the version file
#
# BLUEPRINT AND CONFIGURATION VARIABLES:
# instance_blueprint_file       Path to the blueprint file
# instance_level_name           Name of the level/world
# instance_ports                Array of ports used by the server
# instance_upnp_ports           Array of ports to manage with UPnP
# instance_install_datetime     When the instance was installed
# instance_compress_backups     Whether to compress backups (true/false)
# instance_use_upnp             Whether to use UPnP port forwarding (0/1)
#
# EXECUTION VARIABLES:
# instance_executable_file      Path to server executable
# instance_executable_arguments Arguments to pass to executable
# instance_stop_command         Command to gracefully stop server
# instance_save_command         Command to save game state
# instance_stop_command_timeout_seconds  Seconds to wait for graceful shutdown
#
# LIFECYCLE MANAGEMENT VARIABLES:
# instance_lifecycle_manager    How the instance is managed (standalone/systemd)
# instance_management_file      Path to the management script
# instance_ufw_file             Path to UFW rules file
# instance_systemd_service_file Path to systemd service file
# instance_systemd_socket_file  Path to systemd socket file
#
# STEAM-SPECIFIC VARIABLES:
# instance_steam_app_id         Steam AppID (for Steam-based games)
# instance_is_steam_account_required  Whether Steam account is needed (0/1)
# instance_platform             Platform type for SteamCMD (default: linux)
################################################################################
################################################################################

################################################################################
#                         VERSION MANAGEMENT FUNCTIONS                          #
################################################################################
# These functions handle retrieving, comparing, and storing version information
# for your game server. For non-Steam games or games with custom versioning
# systems, you'll likely need to override these functions.
################################################################################

# Gets the latest available version of the server from the remote source
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - echo "$version": Success (prints version number to stdout)
# - return 0: Success
# - return 1: Error (version couldn't be determined)
#
# PURPOSE:
# This function is called when checking for updates or installing the server.
# It should query whatever source provides version information for your game
# (API, website, file download, etc.) and return the latest available version.
#
# COMMON IMPLEMENTATION PATTERNS:
# - REST API query (for games with version APIs)
# - Web scraping (for games that list versions on websites)
# - File download with version in filename or content
# - GitHub releases API for open source games
# function _get_latest_version() {
#   # Example implementation for a server with version API
#   local latest_version
#   local api_url="https://api.example.com/game/latest-version"
#
#   __print_info "Retrieving latest version from $api_url"
#
#   # Attempt to get version with a timeout
#   latest_version=$(curl --connect-timeout 10 -m 30 -sSL "$api_url")
#
#   # Validate response
#   if [[ -z "$latest_version" ]]; then
#     __print_error "Failed to retrieve latest version: Empty response"
#     return 1
#   fi
#
#   # Validate version format (example: check if it's a valid version string)
#   if ! [[ "$latest_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
#     __print_error "Invalid version format: $latest_version"
#     return 1
#   fi
#
#   __print_info "Latest version: $latest_version"
#   echo "$latest_version"
#   return 0
# }

# Gets the currently installed version from the version file
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - echo "$version": Success (prints installed version to stdout)
# - return 0: Success
# - return 1: Error (version couldn't be determined)
#
# PURPOSE:
# This function retrieves the currently installed version of the server,
# typically from the version file. For games with special version storage,
# override this function to use your custom method.
# function _get_installed_version() {
#   # Example for games that store version in a custom location
#   local installed_version
#
#   # Check if version file exists
#   if [[ ! -f "$instance_version_file" ]]; then
#     __print_error "Version file not found at $instance_version_file"
#     return 1
#   fi
#
#   # Read version from file
#   installed_version=$(<"$instance_version_file")
#
#   # Validate version
#   if [[ -z "$installed_version" ]]; then
#     __print_error "Empty version found in $instance_version_file"
#     return 1
#   fi
#
#   echo "$installed_version"
#   return 0
# }

# Compares two version strings to determine which is newer
#
# INPUT:
# - $1: First version string
# - $2: Second version string
#
# OUTPUT:
# - return 0: Versions are equal
# - return 1: First version is newer
# - return 2: Second version is newer
# - return 3: Error in comparison
#
# PURPOSE:
# This function determines the relationship between two version strings.
# Override this for games with non-standard versioning schemes.
# function _compare_versions() {
#   local version1=$1
#   local version2=$2
#
#   # Validate inputs
#   if [[ -z "$version1" ]] || [[ -z "$version2" ]]; then
#     __print_error "Cannot compare empty version strings"
#     return 3
#   fi
#
#   # Example implementation for semantic versioning
#   local -a v1_parts v2_parts
#   IFS='.' read -ra v1_parts <<< "$version1"
#   IFS='.' read -ra v2_parts <<< "$version2"
#
#   # Validate parts
#   if [[ ${#v1_parts[@]} -eq 0 ]] || [[ ${#v2_parts[@]} -eq 0 ]]; then
#     __print_error "Invalid version format: $version1 or $version2"
#     return 3
#   fi
#
#   # Compare major, minor, patch
#   for i in {0..2}; do
#     # Default to 0 if the component doesn't exist
#     local v1_comp="${v1_parts[$i]:-0}"
#     local v2_comp="${v2_parts[$i]:-0}"
#
#     if (( v1_comp > v2_comp )); then
#       __print_info "Version $version1 is newer than $version2"
#       return 1
#     elif (( v1_comp < v2_comp )); then
#       __print_info "Version $version2 is newer than $version1"
#       return 2
#     fi
#   done
#
#   __print_info "Versions are equal: $version1 = $version2"
#   return 0  # Versions are equal
# }

# Saves the current version to the version file
#
# INPUT:
# - $1: Version string to save
#
# OUTPUT:
# - return 0: Success
# - return 1: Error (couldn't save version)
#
# PURPOSE:
# This function stores the version information after a successful installation
# or update. Override for games that store version in a custom location or format.
# function _save_version() {
#   local version=$1
#
#   # Validate input
#   if [[ -z "$version" ]]; then
#     __print_error "Cannot save empty version string"
#     return 1
#   fi
#
#   __print_info "Saving version $version to $instance_version_file"
#
#   # Create directory if it doesn't exist
#   local dir_path
#   dir_path=$(dirname "$instance_version_file")
#   mkdir -p "$dir_path" || {
#     __print_error "Failed to create directory $dir_path"
#     return 1
#   }
#
#   # Write version to file
#   echo "$version" > "$instance_version_file" || {
#     __print_error "Failed to write to $instance_version_file"
#     return 1
#   }
#
#   __print_success "Version $version saved successfully"
#   return 0
# }

################################################################################
#                      DOWNLOAD AND DEPLOYMENT FUNCTIONS                        #
################################################################################
# These functions handle downloading server files, deploying them to the
# installation directory, and updating the server to newer versions.
# Override these for non-Steam games or games with custom installation methods.
################################################################################

# Downloads server files for a specific version
#
# INPUT:
# - $1: Version to download (can be "latest" or specific version string)
# - $2: Destination directory (usually defaults to instance_temp_dir)
# - $3: (Optional) Additional parameter (e.g., Steam AppID or variant)
#
# OUTPUT:
# - return 0: Success (files downloaded and extracted if needed)
# - return 1: Error (download or extraction failed)
#
# PURPOSE:
# This function is responsible for acquiring the server files from their source
# and placing them in a temporary directory. For non-Steam games, this often
# involves custom download URLs, authentication, or special extraction procedures.
# function _download() {
#   local version=$1
#   local dest=${2:-$instance_temp_dir}
#   local variant=$3
#
#   __print_info "Downloading server files version $version to $dest"
#
#   # Create destination directory
#   mkdir -p "$dest" || {
#     __print_error "Failed to create destination directory $dest"
#     return 1
#   }
#
#   # Example for downloadable ZIP server
#   local download_url="https://example.com/game-server-$version.zip"
#   local output_file="$dest/server.zip"
#
#   __print_info "Fetching from $download_url"
#
#   # Download with progress display and error handling
#   if ! wget --progress=bar:force:noscroll -O "$output_file" "$download_url"; then
#     __print_error "Download failed from $download_url"
#     return 1
#   fi
#
#   # Verify downloaded file
#   if [[ ! -f "$output_file" ]] || [[ ! -s "$output_file" ]]; then
#     __print_error "Download verification failed - file is missing or empty"
#     return 1
#   fi
#
#   __print_info "Extracting files to $dest"
#
#   # Extract files
#   if ! unzip -o -q "$output_file" -d "$dest"; then
#     __print_error "Failed to extract server files"
#     return 1
#   fi
#
#   # Clean up the archive
#   rm -f "$output_file"
#
#   __print_success "Download and extraction complete"
#   return 0
# }

# Deploys server files from the temporary directory to the installation directory
#
# INPUT:
# - $1: Source directory (defaults to instance_temp_dir)
# - $2: Destination directory (defaults to instance_install_dir)
#
# OUTPUT:
# - return 0: Success (files deployed correctly)
# - return 1: Error (deployment failed)
#
# PURPOSE:
# This function moves files from the temporary download location to the final
# installation directory. It may need customization for games that require
# special handling for configuration files or save data during updates.
# function _deploy() {
#   local source=${1:-$instance_temp_dir}
#   local dest=${2:-$instance_install_dir}
#
#   __print_info "Deploying files from $source to $dest"
#
#   # Check if source directory is empty
#   if [[ -z "$(ls -A "$source" 2>/dev/null)" ]]; then
#     __print_error "Source directory is empty, nothing to deploy"
#     return 1
#   fi
#
#   # Check if destination directory exists
#   if [[ ! -d "$dest" ]]; then
#     __print_info "Creating destination directory $dest"
#     mkdir -p "$dest" || {
#       __print_error "Failed to create destination directory $dest"
#       return 1
#     }
#   fi
#
#   # Identify and backup configuration files before deployment
#   if [[ -d "$dest" && ! -z "$(ls -A "$dest" 2>/dev/null)" ]]; then
#     __print_info "Preserving configuration files"
#
#     # Example - backup config files
#     for config_file in "$dest"/server.cfg "$dest"/settings.json; do
#       if [[ -f "$config_file" ]]; then
#         __print_info "Backing up $(basename "$config_file")"
#         cp -f "$config_file" "${config_file}.bak" || __print_warning "Failed to backup $(basename "$config_file")"
#       fi
#     done
#   fi
#
#   # Copy files, preserving attributes
#   __print_info "Copying files to installation directory"
#   if ! cp -rfp "$source"/* "$dest/"; then
#     __print_error "Failed to copy files to $dest"
#     return 1
#   fi
#
#   # Restore configuration files
#   for config_file in "$dest"/server.cfg.bak "$dest"/settings.json.bak; do
#     if [[ -f "$config_file" ]]; then
#       __print_info "Restoring $(basename "${config_file%.bak}")"
#       mv -f "$config_file" "${config_file%.bak}" || __print_warning "Failed to restore $(basename "${config_file%.bak}")"
#     fi
#   done
#
#   # Clean up source directory
#   __print_info "Cleaning up temporary files"
#   rm -rf "${source:?}"/* || __print_warning "Failed to clean up $source"
#
#   __print_success "Deployment complete"
#   return 0
# }

# Updates the server to the latest version
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - return 0: Success (server updated or already at latest version)
# - return 1: Error (update failed)
#
# PURPOSE:
# This function orchestrates the update process by checking versions,
# downloading new files if needed, and handling the deployment process.
# Override this for games with complex update procedures or dependencies.
# function _update() {
#   __print_info "Checking for updates..."
#
#   # Check if server is running
#   if _is_active &>/dev/null; then
#     __print_error "Server is currently running. Please stop it before updating."
#     return 1
#   fi
#
#   local latest_version current_version
#
#   # Get the latest available version
#   latest_version=$(_get_latest_version)
#   if [[ $? -ne 0 || -z "$latest_version" ]]; then
#     __print_error "Failed to retrieve latest version information"
#     return 1
#   fi
#
#   # Get the current installed version
#   current_version=$(_get_installed_version)
#   if [[ $? -ne 0 ]]; then
#     __print_warning "Cannot determine current version, assuming first installation"
#     current_version="0.0.0"
#   fi
#
#   __print_info "Current version: $current_version"
#   __print_info "Latest version: $latest_version"
#
#   # Compare the versions
#   _compare_versions "$current_version" "$latest_version"
#   local comparison_result=$?
#
#   case $comparison_result in
#     0) # Versions are equal
#       __print_success "Server is already at the latest version ($current_version)"
#       return 0
#       ;;
#     2) # Latest version is newer
#       __print_info "New version available. Updating $current_version → $latest_version"
#
#       # Create backup of current installation
#       __print_info "Creating backup of current installation"
#       local datetime
#       datetime="$(date +"%Y%m%d_%H%M%S")"
#       local backup_dir="$instance_backups_dir/pre_update_${datetime}"
#
#       mkdir -p "$backup_dir" || __print_warning "Failed to create backup directory, continuing without backup"
#
#       if [[ -d "$backup_dir" ]]; then
#         cp -rf "$instance_install_dir"/* "$backup_dir"/ 2>/dev/null || __print_warning "Backup partially failed, continuing update"
#       fi
#
#       # Download new version
#       if ! _download "$latest_version" "$instance_temp_dir"; then
#         __print_error "Failed to download version $latest_version"
#         return 1
#       fi
#
#       # Deploy the new version
#       if ! _deploy "$instance_temp_dir" "$instance_install_dir"; then
#         __print_error "Failed to deploy version $latest_version"
#         return 1
#       fi
#
#       # Save the new version information
#       if ! _save_version "$latest_version"; then
#         __print_error "Failed to save version information for $latest_version"
#         return 1
#       fi
#
#       __print_success "Update completed successfully. New version: $latest_version"
#       return 0
#       ;;
#     1) # Current version is newer (unusual case)
#       __print_warning "Current version ($current_version) is newer than latest available ($latest_version). This is unusual and might indicate a problem."
#       return 1
#       ;;
#     *) # Any other result indicates an error
#       __print_error "Error comparing versions"
#       return 1
#       ;;
#   esac
# }

################################################################################
#                          SERVER CONTROL FUNCTIONS                             #
################################################################################
# These functions handle starting, stopping, and controlling the server process.
# Override these for games with special startup requirements, custom shutdown
# procedures, or non-standard command input methods.
################################################################################

# Starts the server in the current terminal (foreground)
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - Launches server process in current terminal
# - return 1: Error (only returned if startup fails)
#
# PURPOSE:
# This function starts the server in the foreground, typically used for
# debugging or when a user wants to directly interact with the console.
# Override for games that need special environment setup or launch parameters.
# function _start() {
#   __print_info "Starting server in foreground mode"
#
#   # Enable UPnP if configured
#   if [[ "$instance_use_upnp" -eq 1 ]]; then
#     _enable_upnp || __print_warning "Failed to enable UPnP, continuing anyway"
#   fi
#
#   # Move to the launch directory
#   cd "$instance_launch_dir" || {
#     __print_error "Failed to change to launch directory: $instance_launch_dir"
#     return 1
#   }
#
#   # Pre-launch setup - example for games that need config preparation
#   if [[ -f "server.properties.template" && ! -f "server.properties" ]]; then
#     __print_info "Generating initial configuration"
#     cp "server.properties.template" "server.properties"
#     # Replace placeholders with actual values
#     sed -i "s/{{SERVER_PORT}}/${instance_ports[0]}/g" "server.properties"
#     sed -i "s/{{WORLD_NAME}}/$instance_level_name/g" "server.properties"
#   fi
#
#   # Execute the server with arguments
#   __print_info "Executing: $instance_executable_file $instance_executable_arguments"
#
#   # The exec replaces the current process with the server
#   # shellcheck disable=SC2086 # We want word splitting for the arguments
#   exec "$instance_executable_file" $instance_executable_arguments
#
#   # This point is only reached if exec fails
#   __print_error "Failed to start server process"
#   return 1
# }

# Starts the server in the background (detached)
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - return 0: Success (server started in background)
# - return 1: Error (startup failed)
#
# PURPOSE:
# This function starts the server as a detached background process, redirecting
# its output to log files. This is the typical way to run game servers.
# Override for games with custom background execution needs.
# function _start_background() {
#   __print_info "Starting server in background mode"
#
#   # Enable UPnP if configured
#   if [[ "$instance_use_upnp" -eq 1 ]]; then
#     _enable_upnp || __print_warning "Failed to enable UPnP, continuing anyway"
#   fi
#
#   # Move to launch directory
#   cd "$instance_launch_dir" || {
#     __print_error "Failed to change to launch directory: $instance_launch_dir"
#     return 1
#   }
#
#   # Create log directory if it doesn't exist
#   mkdir -p "$instance_logs_dir" || {
#     __print_error "Failed to create logs directory: $instance_logs_dir"
#     return 1
#   }
#
#   # Create a named pipe for communication if it doesn't exist
#   if [[ ! -p "$instance_socket_file" ]]; then
#     mkfifo "$instance_socket_file" || {
#       __print_error "Failed to create communication pipe: $instance_socket_file"
#       return 1
#     }
#   fi
#
#   # Generate log filename with timestamp
#   local timestamp
#   timestamp=$(date +"%Y%m%d-%H%M%S")
#   local log_file="$instance_logs_dir/console-$timestamp.log"
#
#   # Start the server in a subshell, redirect input from the named pipe and output to log
#   (
#     # Send server output to both the log file and a rotated log buffer
#     # shellcheck disable=SC2086 # We want word splitting for the arguments
#     "$instance_executable_file" $instance_executable_arguments < "$instance_socket_file" > >(tee -a "$log_file") 2>&1
#   ) &
#
#   # Store the PID
#   local server_pid=$!
#   echo "$server_pid" > "$instance_pid_file" || {
#     __print_error "Failed to write PID file: $instance_pid_file"
#     kill -TERM "$server_pid" 2>/dev/null
#     return 1
#   }
#
#   # Verify process started correctly
#   if ! kill -0 "$server_pid" 2>/dev/null; then
#     __print_error "Server process failed to start or terminated immediately"
#     [[ -f "$instance_pid_file" ]] && rm -f "$instance_pid_file"
#     return 1
#   fi
#
#   # Keep pipe open to prevent EOF (which would terminate the server)
#   ( tail -f /dev/null > "$instance_socket_file" ) &
#   echo $! > "$TAIL_PID_FILE"
#
#   __print_success "Server started with PID $server_pid"
#   __print_info "Log file: $log_file"
#   return 0
# }

# Kills all processes related to the server forcefully
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - return 0: Success (processes killed or none found)
# - return 1: Error (failed to kill some processes)
#
# PURPOSE:
# This function forcefully terminates all server processes when a clean
# shutdown isn't possible. Override for games with complex process hierarchies.
# function _kill_all_processes() {
#   __print_info "Forcefully terminating server processes"
#
#   local failure=0
#
#   # Kill the tail process keeping the pipe open
#   if [[ -f "$TAIL_PID_FILE" ]]; then
#     local tail_pid
#     tail_pid=$(<"$TAIL_PID_FILE")
#     if [[ -n "$tail_pid" ]]; then
#       if kill -0 "$tail_pid" 2>/dev/null; then
#         __print_info "Terminating pipe process (PID: $tail_pid)"
#         kill -TERM "$tail_pid" 2>/dev/null || {
#           __print_warning "Failed to terminate pipe process, attempting force kill"
#           kill -KILL "$tail_pid" 2>/dev/null || failure=1
#         }
#       fi
#     fi
#     rm -f "$TAIL_PID_FILE"
#   fi
#
#   # Get main server PID
#   if [[ -f "$instance_pid_file" ]]; then
#     local server_pid
#     server_pid=$(<"$instance_pid_file")
#
#     if [[ -n "$server_pid" ]]; then
#       # First try to identify child processes
#       local child_pids
#       child_pids=$(pgrep -P "$server_pid" 2>/dev/null)
#
#       # Kill child processes first if found
#       if [[ -n "$child_pids" ]]; then
#         __print_info "Terminating child processes: $child_pids"
#         # Try graceful termination first
#         kill -TERM $child_pids 2>/dev/null
#         sleep 2
#
#         # Force kill any remaining children
#         for pid in $child_pids; do
#           if kill -0 "$pid" 2>/dev/null; then
#             __print_warning "Child process $pid still running, force killing"
#             kill -KILL "$pid" 2>/dev/null || failure=1
#           fi
#         done
#       fi
#
#       # Now kill the main process if it still exists
#       if kill -0 "$server_pid" 2>/dev/null; then
#         __print_info "Terminating main server process (PID: $server_pid)"
#         kill -TERM "$server_pid" 2>/dev/null
#         sleep 2
#
#         # Force kill if still running
#         if kill -0 "$server_pid" 2>/dev/null; then
#           __print_warning "Server process still running, force killing"
#           kill -KILL "$server_pid" 2>/dev/null || failure=1
#         fi
#       fi
#     fi
#
#     # Remove PID file
#     rm -f "$instance_pid_file"
#   fi
#
#   # Final cleanup - find any processes matching the executable name
#   local remaining_pids
#   remaining_pids=$(pgrep -f "$(basename "$instance_executable_file")" 2>/dev/null)
#
#   if [[ -n "$remaining_pids" ]]; then
#     __print_warning "Found additional server processes: $remaining_pids"
#     kill -KILL $remaining_pids 2>/dev/null || failure=1
#   fi
#
#   # Clean up socket file
#   [[ -p "$instance_socket_file" ]] && rm -f "$instance_socket_file"
#
#   if [[ $failure -eq 1 ]]; then
#     __print_error "Some processes may still be running"
#     return 1
#   fi
#
#   __print_success "All server processes terminated"
#   return 0
# }

# Stops the server gracefully with optional save
#
# INPUT:
# - $1: (Optional) No-save flag (set to 1 to skip saving)
# - $2: (Optional) No-graceful flag (set to 1 to force kill)
#
# OUTPUT:
# - return 0: Success (server stopped)
# - return 1: Error (stop failed)
#
# PURPOSE:
# This function attempts to gracefully stop the server, first saving if requested,
# then waiting for a clean shutdown before resorting to force termination.
# Override for games with special shutdown procedures.
# function _stop_server() {
#   local no_save=$1
#   local no_graceful=$2
#
#   __print_info "Stopping server"
#
#   # Check if server is actually running
#   if ! _is_active &>/dev/null; then
#     __print_warning "Server is not running"
#     return 0
#   fi
#
#   # First save if requested and available
#   if [[ "$no_save" != "1" && -n "$instance_save_command" ]]; then
#     __print_info "Saving game before shutdown"
#     _send_save_command
#
#     # Give time for save to complete
#     sleep 5
#   fi
#
#   # If graceful shutdown is requested and supported
#   if [[ "$no_graceful" != "1" && -n "$instance_stop_command" ]]; then
#     __print_info "Attempting graceful shutdown"
#
#     # Send stop command
#     _send_input "$instance_stop_command"
#
#     # Wait for server to stop (up to configured timeout or default 30s)
#     local timeout=${instance_stop_command_timeout_seconds:-30}
#     __print_info "Waiting up to $timeout seconds for server to exit"
#
#     while _is_active &>/dev/null && [[ $timeout -gt 0 ]]; do
#       sleep 1
#       timeout=$((timeout - 1))
#
#       # Print countdown every 5 seconds
#       if (( timeout % 5 == 0 )) && (( timeout > 0 )); then
#         __print_info "$timeout seconds remaining for graceful shutdown"
#       fi
#     done
#
#     # If server is still running after timeout
#     if _is_active &>/dev/null; then
#       __print_warning "Graceful shutdown timed out, forcing termination"
#       _kill_all_processes
#     else
#       __print_success "Server shut down gracefully"
#     fi
#   else
#     # Skip graceful shutdown, kill directly
#     __print_info "Using immediate termination"
#     _kill_all_processes
#   fi
#
#   # Disable UPnP if it was enabled
#   if [[ "$instance_use_upnp" -eq 1 ]]; then
#     _disable_upnp || __print_warning "Failed to disable UPnP"
#   fi
#
#   # Final check to make sure server is really stopped
#   if _is_active &>/dev/null; then
#     __print_error "Failed to stop server"
#     return 1
#   fi
#
#   __print_success "Server stopped successfully"
#   return 0
# }

# Sends a save command to the server
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - return 0: Success (save command sent)
# - return 1: Error (couldn't send command or no save command defined)
#
# PURPOSE:
# This function sends a command to the server to save the game state.
# Override for games with special save procedures or command formats.
# function _send_save_command() {
#   # Check if save command is configured
#   if [[ -z "$instance_save_command" ]]; then
#     __print_error "No save command defined for this server"
#     return 1
#   fi
#
#   __print_info "Sending save command: $instance_save_command"
#
#   # Check if server is running
#   if ! _is_active &>/dev/null; then
#     __print_error "Server is not running, cannot save"
#     return 1
#   fi
#
#   # Send the command
#   if ! _send_input "$instance_save_command"; then
#     __print_error "Failed to send save command"
#     return 1
#   fi
#
#   # Allow time for save to complete
#   local save_timeout=${config_save_command_timeout_seconds:-5}
#   __print_info "Waiting ${save_timeout}s for save operation to complete"
#   sleep "$save_timeout"
#
#   __print_success "Save command sent successfully"
#   return 0
# }

# Sends input to the server
#
# INPUT:
# - $1: Command string to send
#
# OUTPUT:
# - return 0: Success (command sent)
# - return 1: Error (couldn't send command)
#
# PURPOSE:
# This function sends commands to a running server. Override for games
# that use special methods for command input (RCON, WebUI, etc).
# function _send_input() {
#   local command=$1
#
#   # Validate command
#   if [[ -z "$command" ]]; then
#     __print_error "Cannot send empty command"
#     return 1
#   fi
#
#   __print_info "Sending command: $command"
#
#   # Verify server is running
#   if ! _is_active &>/dev/null; then
#     __print_error "Server is not running, cannot send command"
#     return 1
#   fi
#
#   # Method 1: Send via named pipe (most common)
#   if [[ -p "$instance_socket_file" ]]; then
#     echo "$command" > "$instance_socket_file" || {
#       __print_error "Failed to write to socket file"
#       return 1
#     }
#     __print_success "Command sent via socket"
#     return 0
#   fi
#
#   # Method 2: Example of RCON implementation
#   # if command -v mcrcon &>/dev/null; then
#   #   local rcon_host="${RCON_HOST:-localhost}"
#   #   local rcon_port="${RCON_PORT:-25575}"
#   #   local rcon_password="${RCON_PASSWORD:-password}"
#   #
#   #   if ! mcrcon -H "$rcon_host" -P "$rcon_port" -p "$rcon_password" "$command"; then
#   #     __print_error "RCON command failed"
#   #     return 1
#   #   fi
#   #   __print_success "Command sent via RCON"
#   #   return 0
#   # fi
#
#   __print_error "No method available to send command to server"
#   return 1
# }

# Checks if the server is currently running
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - return 0: True (server is running)
# - return 1: False (server is not running)
#
# PURPOSE:
# This function determines if the server process is currently active.
# Override for games with special process detection requirements.
# function _is_active() {
#   # Check if PID file exists and contains a valid PID
#   if [[ -f "$instance_pid_file" ]]; then
#     local pid
#     pid=$(<"$instance_pid_file")
#
#     if [[ -n "$pid" ]]; then
#       # Check if process exists
#       if kill -0 "$pid" 2>/dev/null; then
#         # Further validate it's the correct process
#         if ps -p "$pid" -o comm= 2>/dev/null | grep -q "$(basename "$instance_executable_file")"; then
#           __print_info "Server is active (PID: $pid)"
#           return 0
#         else
#           __print_warning "PID $pid exists but is not the server process, cleaning up"
#           rm -f "$instance_pid_file"
#         fi
#       else
#         __print_warning "Stale PID file found, cleaning up"
#         rm -f "$instance_pid_file"
#       fi
#     fi
#   fi
#
#   # Secondary check - look for process by executable name
#   local found_pid
#   found_pid=$(pgrep -f "$(basename "$instance_executable_file")" 2>/dev/null)
#
#   if [[ -n "$found_pid" ]]; then
#     __print_warning "Server process found ($found_pid) but PID file missing, recreating"
#     echo "$found_pid" > "$instance_pid_file"
#     return 0
#   fi
#
#   __print_info "Server is not running"
#   return 1
# }

################################################################################
#                             PORT MANAGEMENT FUNCTIONS                         #
################################################################################
# These functions handle UPnP port forwarding capabilities. Override these
# if your game requires special port management or custom UPnP configuration.
################################################################################

# Enables UPnP port forwarding for the configured ports
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - return 0: Success (ports forwarded)
# - return 1: Error (forwarding failed)
#
# PURPOSE:
# This function sets up UPnP port forwarding for all ports needed by the server.
# Override if your game requires special port configuration or handling.
# function _enable_upnp() {
#   # Check if upnpc tool is available
#   if ! command -v upnpc &>/dev/null; then
#     __print_error "UPnP tool (upnpc) not found. Please install miniupnpc package."
#     return 1
#   fi
#
#   # Check if UPnP ports are defined
#   if [[ -z "${instance_upnp_ports[*]}" ]]; then
#     __print_error "No UPnP ports defined for this instance"
#     return 1
#   }
#
#   __print_info "Enabling UPnP port forwarding for ${#instance_upnp_ports[@]} ports"
#
#   local success=0
#   local failure=0
#   local output
#
#   # Set up each port
#   for port in "${instance_upnp_ports[@]}"; do
#     __print_info "Setting up port forward for $port"
#
#     # Check if port is in valid format (number or number/protocol)
#     local port_number protocol
#     if [[ "$port" == */* ]]; then
#       port_number="${port%/*}"
#       protocol="${port#*/}"
#     else
#       port_number="$port"
#       protocol="tcp" # Default to TCP
#     fi
#
#     # Validate port number
#     if ! [[ "$port_number" =~ ^[0-9]+$ ]] || [ "$port_number" -lt 1 ] || [ "$port_number" -gt 65535 ]; then
#       __print_error "Invalid port number: $port_number"
#       failure=$((failure + 1))
#       continue
#     fi
#
#     # Execute upnpc command with port info
#     if output=$(upnpc -e "$instance_name ($port_number/$protocol)" -r "$port_number" "$protocol" 2>&1); then
#       __print_success "Successfully forwarded port $port_number/$protocol"
#       success=$((success + 1))
#     else
#       __print_error "Failed to forward port $port_number/$protocol"
#       __print_error "Error: $output"
#       failure=$((failure + 1))
#     fi
#   done
#
#   # Report results
#   __print_info "UPnP port forwarding: $success succeeded, $failure failed"
#
#   if [ "$failure" -gt 0 ]; then
#     __print_warning "Some ports could not be forwarded"
#     if [ "$success" -eq 0 ]; then
#       return 1
#     fi
#   fi
#
#   return 0
# }

# Disables UPnP port forwarding for the configured ports
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - return 0: Success (port forwarding removed)
# - return 1: Error (removal failed)
#
# PURPOSE:
# This function removes UPnP port forwarding configurations previously set up.
# Override if your game requires special port cleanup procedures.
# function _disable_upnp() {
#   # Check if upnpc tool is available
#   if ! command -v upnpc &>/dev/null; then
#     __print_error "UPnP tool (upnpc) not found. Please install miniupnpc package."
#     return 1
#   }
#
#   # Check if UPnP ports are defined
#   if [[ -z "${instance_upnp_ports[*]}" ]]; then
#     __print_info "No UPnP ports defined for this instance, nothing to disable"
#     return 0
#   }
#
#   __print_info "Disabling UPnP port forwarding"
#
#   local success=0
#   local failure=0
#   local output
#
#   # Remove each port forward
#   for port in "${instance_upnp_ports[@]}"; do
#     # Extract port number and protocol
#     local port_number protocol
#     if [[ "$port" == */* ]]; then
#       port_number="${port%/*}"
#       protocol="${port#*/}"
#     else
#       port_number="$port"
#       protocol="tcp" # Default to TCP
#     fi
#
#     # Execute upnpc deletion command
#     if output=$(upnpc -d "$port_number" "$protocol" 2>&1); then
#       __print_success "Successfully removed port forward for $port_number/$protocol"
#       success=$((success + 1))
#     else
#       __print_error "Failed to remove port forward for $port_number/$protocol"
#       __print_error "Error: $output"
#       failure=$((failure + 1))
#     fi
#   done
#
#   # Report results
#   __print_info "UPnP port removal: $success succeeded, $failure failed"
#
#   if [ "$failure" -gt 0 ]; then
#     __print_warning "Some port forwards could not be removed"
#     if [ "$success" -eq 0 ]; then
#       return 1
#     fi
#   fi
#
#   return 0
# }

################################################################################
#                             LOG MANAGEMENT FUNCTIONS                          #
################################################################################
# These functions handle displaying and managing server logs. Override these
# if your game uses custom log formats or locations.
################################################################################

# Prints server logs to the console
#
# INPUT:
# - $1: (Optional) Follow flag ("--follow" to continuously display new log entries)
#
# OUTPUT:
# - Prints logs to stdout
# - return 0: Success
# - return 1: Error (couldn't access logs)
#
# PURPOSE:
# This function displays server logs, either showing the latest entries or
# continuously following new entries as they are created. Override for
# games with custom log handling or rotated log files.
# function _print_logs() {
#   local follow="${1:-}"
#   local lines=20 # Default number of lines to show
#
#   __print_info "Accessing server logs"
#
#   # Find the latest log file
#   local log_files
#   local latest_log_file=""
#
#   # Check if logs directory exists
#   if [[ ! -d "$instance_logs_dir" ]]; then
#     __print_error "Logs directory does not exist: $instance_logs_dir"
#     return 1
#   fi
#
#   # Get list of log files sorted by modification time (newest first)
#   log_files=($(find "$instance_logs_dir" -type f -name "*.log" -exec ls -t {} \;))
#
#   # Check if any log files were found
#   if [[ ${#log_files[@]} -eq 0 ]]; then
#     __print_error "No log files found in $instance_logs_dir"
#     return 1
#   fi
#
#   # Use the most recent log file
#   latest_log_file="${log_files[0]}"
#
#   __print_info "Using log file: $(basename "$latest_log_file")"
#
#   # Display logs based on follow flag
#   if [[ "$follow" == "--follow" ]]; then
#     __print_info "Following logs (press Ctrl+C to stop)"
#
#     # Handle log rotation while following
#     if command -v inotifywait &>/dev/null; then
#       # Advanced implementation with log rotation detection
#       (
#         trap 'exit 0' INT TERM
#
#         while true; do
#           # Show current log content
#           tail -F "$latest_log_file" &
#           tail_pid=$!
#
#           # Wait for changes in the log directory (new files)
#           inotifywait -e create -e moved_to "$instance_logs_dir" >/dev/null 2>&1
#
#           # Kill current tail process
#           kill "$tail_pid" 2>/dev/null
#
#           # Find new latest log
#           local new_log_files
#           new_log_files=($(find "$instance_logs_dir" -type f -name "*.log" -exec ls -t {} \;))
#
#           if [[ ${#new_log_files[@]} -gt 0 ]]; then
#             if [[ "${new_log_files[0]}" != "$latest_log_file" ]]; then
#               latest_log_file="${new_log_files[0]}"
#               __print_info "Switched to new log file: $(basename "$latest_log_file")"
#             fi
#           fi
#         done
#       )
#     else
#       # Simple implementation without rotation detection
#       tail -f "$latest_log_file"
#     fi
#   else
#     # Just show the last several lines
#     __print_info "Showing last $lines lines of log"
#     tail -n "$lines" "$latest_log_file"
#   fi
#
#   return 0
# }

# Function to handle log rotation and cleanup
#
# INPUT:
# - $1: (Optional) Max number of log files to keep
#
# OUTPUT:
# - return 0: Success
# - return 1: Error
#
# PURPOSE:
# This function manages log rotation by removing older log files.
# Override to implement custom log rotation policies.
# function _rotate_logs() {
#   local max_logs=${1:-10} # Default to keeping 10 log files
#
#   __print_info "Rotating logs (keeping last $max_logs files)"
#
#   # Check if logs directory exists
#   if [[ ! -d "$instance_logs_dir" ]]; then
#     __print_error "Logs directory does not exist: $instance_logs_dir"
#     return 1
#   fi
#
#   # Get all log files sorted by modification time (oldest first)
#   local log_files=($(find "$instance_logs_dir" -type f -name "*.log" -exec ls -t {} \; | tac))
#   local file_count=${#log_files[@]}
#
#   # If we have more logs than our max, remove the oldest ones
#   if (( file_count > max_logs )); then
#     local files_to_remove=$((file_count - max_logs))
#     __print_info "Found $file_count log files, removing $files_to_remove old logs"
#
#     # Delete oldest logs
#     for (( i=0; i<files_to_remove; i++ )); do
#       local file_to_remove="${log_files[$i]}"
#       __print_info "Removing old log: $(basename "$file_to_remove")"
#       rm -f "$file_to_remove" || {
#         __print_warning "Failed to remove log file: $file_to_remove"
#       }
#     done
#
#     __print_success "Log rotation complete"
#   else
#     __print_info "Log count ($file_count) is within limits, no rotation needed"
#   fi
#
#   return 0
# }

################################################################################
#                          BACKUP MANAGEMENT FUNCTIONS                          #
################################################################################
# These functions handle creating, listing, and restoring backups of your game
# server data. Override these if your game has special backup requirements or
# complex save data structures.
################################################################################

# Creates a backup of the server
#
# INPUT:
# - $1: (Optional) Custom backup name suffix
#
# OUTPUT:
# - return 0: Success
# - return 1: Error
#
# PURPOSE:
# This function creates a backup of essential server data, typically focusing
# on world saves, player data, and configurations. Override for games with
# complex data requirements or special backup procedures.
# function _create_backup() {
#   local backup_name_suffix="${1:-}"
#   local timestamp
#   timestamp=$(date +"%Y%m%d-%H%M%S")
#
#   # Get current version for backup identification
#   local current_version
#   current_version=$(_get_installed_version) || current_version="unknown"
#
#   # Create backup name
#   local backup_name="${instance_name}-${current_version}-${timestamp}${backup_name_suffix:+-$backup_name_suffix}"
#   local backup_path="$instance_backups_dir/$backup_name"
#
#   __print_info "Creating backup: $backup_name"
#
#   # Create backup directory
#   mkdir -p "$backup_path" || {
#     __print_error "Failed to create backup directory: $backup_path"
#     return 1
#   }
#
#   # Save game if server is running and save command is available
#   if _is_active &>/dev/null && [[ -n "$instance_save_command" ]]; then
#     __print_info "Server is running, saving game state before backup"
#     _send_save_command
#
#     # Wait for save to complete
#     local save_timeout=${config_save_command_timeout_seconds:-5}
#     __print_info "Waiting ${save_timeout}s for save operation to complete"
#     sleep "$save_timeout"
#   fi
#
#   # Determine what needs to be backed up
#   local success=true
#   local backup_failed=false
#
#   # 1. Always back up the saves directory
#   if [[ -d "$instance_saves_dir" && -n "$(ls -A "$instance_saves_dir" 2>/dev/null)" ]]; then
#     __print_info "Backing up save data"
#     mkdir -p "$backup_path/saves" || success=false
#
#     if $success; then
#       cp -r "$instance_saves_dir"/* "$backup_path/saves/" || {
#         __print_error "Failed to copy save files"
#         backup_failed=true
#       }
#     fi
#   else
#     __print_info "No save data found to back up"
#   fi
#
#   # 2. Back up essential configuration files
#   local config_dir="$backup_path/config"
#   mkdir -p "$config_dir" || success=false
#
#   if $success; then
#     # Loop through common configuration files and locations
#     for config_file in "$instance_install_dir"/server.cfg \
#                        "$instance_install_dir"/server.properties \
#                        "$instance_install_dir"/server.json \
#                        "$instance_install_dir"/config.json \
#                        "$instance_install_dir"/settings.ini; do
#       if [[ -f "$config_file" ]]; then
#         local dest_file="$config_dir/$(basename "$config_file")"
#         __print_info "Backing up configuration: $(basename "$config_file")"
#         cp -p "$config_file" "$dest_file" || {
#           __print_warning "Failed to backup $(basename "$config_file")"
#         }
#       fi
#     done
#
#     # Look for config directories
#     for config_dir_source in "$instance_install_dir"/config \
#                             "$instance_install_dir"/configs \
#                             "$instance_install_dir"/settings; do
#       if [[ -d "$config_dir_source" ]]; then
#         local dir_name=$(basename "$config_dir_source")
#         __print_info "Backing up configuration directory: $dir_name"
#         mkdir -p "$config_dir/$dir_name" || continue
#         cp -rp "$config_dir_source"/* "$config_dir/$dir_name/" 2>/dev/null || {
#           __print_warning "Failed to backup some files in $dir_name"
#         }
#       fi
#     done
#   fi
#
#   # Create metadata file
#   __print_info "Creating backup metadata"
#   {
#     echo "Backup-Name: $backup_name"
#     echo "Created: $(date)"
#     echo "Instance: $instance_name"
#     echo "Version: $current_version"
#     echo "System: $(uname -a)"
#   } > "$backup_path/backup.meta"
#
#   # Compress the backup if configured
#   if [[ "$instance_compress_backups" == "true" ]]; then
#     __print_info "Compressing backup"
#     local compressed_file="$instance_backups_dir/${backup_name}.tar.gz"
#
#     if ! tar -czf "$compressed_file" -C "$instance_backups_dir" "$backup_name"; then
#       __print_error "Failed to compress backup"
#       backup_failed=true
#     else
#       # Remove the uncompressed directory after successful compression
#       rm -rf "$backup_path"
#       __print_success "Backup compressed to $compressed_file"
#     fi
#   fi
#
#   if $backup_failed; then
#     __print_error "Backup completed with errors"
#     return 1
#   else
#     __print_success "Backup completed successfully"
#     return 0
#   fi
# }

# Lists available backups
#
# INPUT:
# - void (no parameters needed)
#
# OUTPUT:
# - Prints backup list to stdout
# - return 0: Success
# - return 1: Error (no backups found or directory doesn't exist)
#
# PURPOSE:
# This function displays a list of available backups along with their creation
# dates and other metadata. Override for custom backup naming or format.
# function _list_backups() {
#   __print_info "Listing available backups"
#
#   # Check if backups directory exists
#   if [[ ! -d "$instance_backups_dir" ]]; then
#     __print_error "Backups directory doesn't exist: $instance_backups_dir"
#     return 1
#   fi
#
#   # Get list of backups (both directories and compressed archives)
#   local backup_dirs=()
#   local backup_archives=()
#
#   # Find backup directories
#   while IFS= read -r dir; do
#     [[ -n "$dir" ]] && backup_dirs+=("$dir")
#   done < <(find "$instance_backups_dir" -maxdepth 1 -type d -name "${instance_name}-*" | sort)
#
#   # Find compressed backups
#   while IFS= read -r archive; do
#     [[ -n "$archive" ]] && backup_archives+=("$archive")
#   done < <(find "$instance_backups_dir" -maxdepth 1 -type f -name "${instance_name}-*.tar.gz" | sort)
#
#   # Combine the lists
#   local all_backups=("${backup_dirs[@]}" "${backup_archives[@]}")
#
#   # Check if backups were found
#   if [[ ${#all_backups[@]} -eq 0 ]]; then
#     __print_info "No backups found for instance: $instance_name"
#     return 1
#   fi
#
#   # Display backup information in a table format
#   echo
#   printf "%-40s %-20s %-15s %-15s\n" "BACKUP NAME" "CREATED" "VERSION" "SIZE"
#   printf "%-40s %-20s %-15s %-15s\n" "$(printf '%0.s-' {1..40})" "$(printf '%0.s-' {1..20})" "$(printf '%0.s-' {1..15})" "$(printf '%0.s-' {1..15})"
#
#   # Process each backup
#   for backup in "${all_backups[@]}"; do
#     local backup_name
#     backup_name=$(basename "$backup")
#     local created_date="Unknown"
#     local version="Unknown"
#     local size
#
#     # Get size
#     if [[ -d "$backup" ]]; then
#       size=$(du -sh "$backup" | awk '{print $1}')
#
#       # Try to extract metadata from backup.meta file
#       if [[ -f "$backup/backup.meta" ]]; then
#         created_date=$(grep "Created:" "$backup/backup.meta" | sed 's/Created: //')
#         version=$(grep "Version:" "$backup/backup.meta" | sed 's/Version: //')
#       fi
#     else
#       # It's an archive
#       size=$(du -h "$backup" | awk '{print $1}')
#
#       # Try to extract version from filename
#       if [[ "$backup_name" =~ ${instance_name}-([^-]+)- ]]; then
#         version="${BASH_REMATCH[1]}"
#       fi
#
#       # Try to get date from file modification time
#       created_date=$(stat -c "%y" "$backup" | cut -d. -f1)
#     fi
#
#     # Truncate backup name if too long
#     if [[ ${#backup_name} -gt 40 ]]; then
#       backup_name="${backup_name:0:37}..."
#     fi
#
#     printf "%-40s %-20s %-15s %-15s\n" "$backup_name" "$created_date" "$version" "$size"
#   done
#
#   echo
#   __print_info "Total backups: ${#all_backups[@]}"
#   return 0
# }

# Restores a backup
#
# INPUT:
# - $1: Backup name (directory or compressed archive)
#
# OUTPUT:
# - return 0: Success
# - return 1: Error
#
# PURPOSE:
# This function restores a previously created backup, replacing the current
# server data. Override for games with complex restoration requirements.
# function _restore_backup() {
#   local backup_name="$1"
#
#   # Validate backup name provided
#   if [[ -z "$backup_name" ]]; then
#     __print_error "No backup name provided"
#     return 1
#   fi
#
#   # Determine full backup path
#   local backup_path
#
#   # Check if it's a directory backup
#   if [[ -d "$instance_backups_dir/$backup_name" ]]; then
#     backup_path="$instance_backups_dir/$backup_name"
#   # Check if it's a compressed backup
#   elif [[ -f "$instance_backups_dir/$backup_name" ]]; then
#     backup_path="$instance_backups_dir/$backup_name"
#   # Otherwise, try to find a partial match
#   else
#     # Try to find a backup with a name containing the provided string
#     local found_backup
#     found_backup=$(find "$instance_backups_dir" -maxdepth 1 \( -type d -o -type f -name "*.tar.gz" \) -name "*${backup_name}*" | head -n 1)
#
#     if [[ -z "$found_backup" ]]; then
#       __print_error "Backup '$backup_name' not found"
#       return 1
#     fi
#
#     backup_path="$found_backup"
#     backup_name=$(basename "$backup_path")
#   fi
#
#   __print_info "Preparing to restore backup: $backup_name"
#
#   # Confirm backup exists
#   if [[ ! -e "$backup_path" ]]; then
#     __print_error "Backup '$backup_path' not found"
#     return 1
#   fi
#
#   # Stop server if running
#   if _is_active &>/dev/null; then
#     __print_info "Server is running, stopping it before restore"
#     _stop_server 1 0  # No save, graceful stop
#
#     # Verify server is stopped
#     if _is_active &>/dev/null; then
#       __print_error "Failed to stop server, cannot proceed with restore"
#       return 1
#     fi
#   fi
#
#   # Create safety backup of current state before restoring
#   __print_info "Creating safety backup of current state"
#   local safety_backup_name="pre_restore_$(date +"%Y%m%d-%H%M%S")"
#
#   if ! _create_backup "$safety_backup_name"; then
#     __print_warning "Failed to create safety backup, but continuing with restore"
#   else
#     __print_success "Safety backup created: $safety_backup_name"
#   fi
#
#   # Prepare temporary workspace for restoration
#   local temp_restore_dir="$instance_temp_dir/restore_$$"
#   mkdir -p "$temp_restore_dir" || {
#     __print_error "Failed to create temporary restoration directory"
#     return 1
#   }
#
#   # Extract backup if it's compressed
#   if [[ "$backup_path" == *.tar.gz ]]; then
#     __print_info "Extracting compressed backup"
#
#     if ! tar -xzf "$backup_path" -C "$temp_restore_dir"; then
#       __print_error "Failed to extract backup archive"
#       rm -rf "$temp_restore_dir"
#       return 1
#     fi
#
#     # Find extracted directory
#     local extracted_dir
#     extracted_dir=$(find "$temp_restore_dir" -mindepth 1 -maxdepth 1 -type d | head -n 1)
#
#     if [[ -z "$extracted_dir" ]]; then
#       __print_error "Failed to find extracted content in backup"
#       rm -rf "$temp_restore_dir"
#       return 1
#     fi
#
#     backup_path="$extracted_dir"
#   fi
#
#   # Restore save data
#   if [[ -d "$backup_path/saves" ]]; then
#     __print_info "Restoring save data"
#
#     # Clear current saves directory
#     if [[ -d "$instance_saves_dir" ]]; then
#       rm -rf "${instance_saves_dir:?}"/* || {
#         __print_error "Failed to clear saves directory"
#         rm -rf "$temp_restore_dir"
#         return 1
#       }
#     else
#       mkdir -p "$instance_saves_dir" || {
#         __print_error "Failed to create saves directory"
#         rm -rf "$temp_restore_dir"
#         return 1
#       }
#     fi
#
#     # Copy backup saves to saves directory
#     cp -r "$backup_path/saves/"* "$instance_saves_dir/" || {
#       __print_error "Failed to restore save files"
#       rm -rf "$temp_restore_dir"
#       return 1
#     }
#   fi
#
#   # Restore configuration files if present
#   if [[ -d "$backup_path/config" ]]; then
#     __print_info "Restoring configuration files"
#
#     # Copy individual config files
#     find "$backup_path/config" -type f -maxdepth 1 -exec cp -p {} "$instance_install_dir/" \; || {
#       __print_warning "Some configuration files failed to restore"
#     }
#
#     # Copy config subdirectories
#     find "$backup_path/config" -mindepth 1 -maxdepth 1 -type d | while read -r config_subdir; do
#       local dir_name
#       dir_name=$(basename "$config_subdir")
#
#       __print_info "Restoring config directory: $dir_name"
#
#       # Create target directory if it doesn't exist
#       mkdir -p "$instance_install_dir/$dir_name"
#
#       # Copy contents
#       cp -rp "$config_subdir/"* "$instance_install_dir/$dir_name/" 2>/dev/null || {
#         __print_warning "Some files in $dir_name failed to restore"
#       }
#     done
#   fi
#
#   # Apply permissions to ensure server can run
#   __print_info "Applying proper permissions to restored files"
#   chmod -R u+rw "$instance_install_dir" "$instance_saves_dir" 2>/dev/null || {
#     __print_warning "Failed to set some permissions"
#   }
#
#   # Clean up
#   rm -rf "$temp_restore_dir"
#
#   __print_success "Backup restored successfully"
#   return 0
# }

# Cleans up old backups based on retention policy
#
# INPUT:
# - $1: (Optional) Number of backups to keep (default: 10)
#
# OUTPUT:
# - return 0: Success
# - return 1: Error
#
# PURPOSE:
# This function removes older backups to free up disk space, keeping
# only the most recent ones. Override to implement custom retention policies.
# function _clean_old_backups() {
#   local keep_count=${1:-10}
#
#   __print_info "Cleaning up old backups (keeping $keep_count most recent)"
#
#   # Check if backup directory exists
#   if [[ ! -d "$instance_backups_dir" ]]; then
#     __print_error "Backup directory doesn't exist: $instance_backups_dir"
#     return 1
#   fi
#
#   # Find all backups, sorted by modification time (oldest first)
#   local all_backups=()
#
#   # Pattern for this instance's backups (directories and compressed files)
#   local backup_pattern="${instance_name}-*"
#
#   # Find and sort backups by modification time (oldest first)
#   while IFS= read -r backup; do
#     [[ -n "$backup" ]] && all_backups+=("$backup")
#   done < <(find "$instance_backups_dir" -maxdepth 1 -name "$backup_pattern" -type d -o -name "${backup_pattern}.tar.gz" -type f | xargs ls -t | tac)
#
#   local total_backups=${#all_backups[@]}
#
#   # If we have more backups than we should keep
#   if [[ $total_backups -gt $keep_count ]]; then
#     local delete_count=$((total_backups - keep_count))
#     __print_info "Found $total_backups backups, will delete $delete_count oldest"
#
#     local deleted=0
#     for (( i=0; i<delete_count; i++ )); do
#       local backup="${all_backups[$i]}"
#       local backup_name=$(basename "$backup")
#
#       __print_info "Deleting old backup: $backup_name"
#
#       rm -rf "$backup" || {
#         __print_warning "Failed to delete backup: $backup_name"
#         continue
#       }
#
#       deleted=$((deleted + 1))
#     done
#
#     __print_success "Deleted $deleted old backups"
#   else
#     __print_info "Only $total_backups backups found (keeping $keep_count), no cleanup needed"
#   fi
#
#   return 0
# }
