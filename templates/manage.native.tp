#!/usr/bin/env bash

# This file is autogenerated
#
# Modifications done to this file will only affect this game server instance.
# Any changes made to this file will be overwritten if the file is regenerated.
# KGSM will not regenerated this file on its own, but there is a command that
# can be manually used to regenerate the file in case something breaks:
# > $KGSM_ROOT/modules/files.sh --instance <instance> --create --manage

debug=
# shellcheck disable=SC2199
if [[ $@ =~ "--debug" ]]; then
  debug=" --debug"
  export PS4='+(\033[0;33m${BASH_SOURCE}:${LINENO}\033[0m): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  set -x
  for a; do
    shift
    case $a in
    --debug) continue ;;
    *) set -- "$@" "$a" ;;
    esac
  done
fi

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Security function to validate configuration keys
# Prevents code injection through malicious config files by ensuring
# only safe variable names can be exported to the environment
function __validate_config_key() {
  local key="$1"

  # Allow only alphanumeric characters and underscores
  # Key must start with letter or underscore
  # This prevents injection of special shell variables or commands
  if [[ "$key" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
    return 0
  else
    return 1
  fi
}

# Function to source the instance configuration file
function __source_instance_config() {
  local config_file="$1"

  if [[ ! -f "$config_file" ]]; then
    echo "ERROR: Instance configuration file not found: $config_file"
    exit 1
  fi

  # Source the configuration file and prefix all variables with "instance_"
  # Added security validation to prevent code injection attacks
  while IFS='=' read -r key value || [ -n "$key" ]; do
    # Skip comments and empty lines
    [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue

    # Remove leading/trailing whitespace
    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"

    # Security check: Validate key name to prevent code injection
    if ! __validate_config_key "$key"; then
      echo "ERROR: Invalid configuration key '$key' in $config_file"
      echo "Configuration keys must contain only alphanumeric characters and underscores,"
      echo "and must start with a letter or underscore."
      exit 1
    fi

    # Remove quotes from value
    value="${value#\"}"
    value="${value%\"}"
    value="${value#\'}"
    value="${value%\'}"

    # Check if the key already starts with "instance_"
    if [[ "$key" =~ ^instance_ ]]; then
      # If it already has the prefix, export it as is
      export "${key}=${value}"
    else
      # Otherwise, add the "instance_" prefix
      export "instance_${key}=${value}"
    fi
  done <"$config_file"
}

# Source the instance configuration file
INSTANCE_NAME="$(basename "$SCRIPT_DIR")"
CONFIG_FILE="$SCRIPT_DIR/${INSTANCE_NAME}.config.ini"

if [[ ! -f "$CONFIG_FILE" ]]; then
  __print_error "Configuration file not found: $CONFIG_FILE"
  exit 1
fi

__source_instance_config "$CONFIG_FILE"

# UPnP state tracking
UPNP_STATE_FILE="$SCRIPT_DIR/.upnp_enabled"
LATEST_LOG_FILE="$instance_logs_dir/latest.log"

self=$(basename "$0")

function usage() {
  echo "
Usage:
  $self OPTION

Options:
  -h, --help                Display this help message
  --start                   Start the server in the current terminal
  --start [--background]    Start the server in the background
  --stop                    Stop the server
  --stop [--no-save]        Do not save on shutdown
  --stop [--no-graceful]    Kill the server process without sending it the
                            stop command.
  --kill                    Kill the server process
  --save                    Save the current game state
  --is-active               Prints if the server is active
  --status                  Display comprehensive runtime status
  --status --json           Output status information as JSON
  --status --fast           Display status without update checking (faster)
  --status --json --fast    Output fast status as JSON
  --input <command>         Send an ad-hoc command to the server

  --logs                    Print last 10 lines of the log (default)
  --logs --tail <number>    Print last <number> lines of the log
  --logs --lines <number>   Alias for --tail (Unix standard)
  --logs -n <number>        Alias for --tail (short form)
  --logs [-f, --follow]     Print live logs (starts with last 10 lines)
  --logs --follow --tail <number>  Follow logs starting with last <number> lines
  --enable-upnp             Enable UPnP ports
  --disable-upnp            Disable UPnP ports

  --download                Downloads the game server files
  --download [version]      Downloads the game server files for a specific version
  --deploy                  Deploys the game server files from the temporary directory
  --update                  Updates the game server files to the latest version

  --list-backups            Print a list of available backups
  --create-backup           Create a backup of the game server files
  --restore-backup <source> Restore a specified backup

  --version                 Print the locally installed version
  --version [--save <ver>]  Save a given version to file
  --version [--latest]      Print the latest available version
  --version [--compare]     Test the local version vs the latest available.
                            If the latest is different, it will be printed to
                            stdout

Examples:
  $self --start --background
  $self --input '/save'
  $self --stop
  $self --logs --tail 50
  $self --logs --follow --tail 100
"
}

SUCCESS="SUCCESS"
INFO="INFO"
ERROR="ERROR"
WARNING="WARNING"

## Colored output
# Check if stdout is tty
if test -t 1; then
  ncolors=0

  # Check for availability of tput
  if command -v tput >/dev/null 2>&1; then
    ncolors="$(tput colors)"
  fi

  # More than 8 means it supports colors
  if [[ $ncolors ]] && [[ "$ncolors" -gt 8 ]]; then
    export COLOR_RED="\033[0;31m"
    export COLOR_GREEN="\033[0;32m"
    export COLOR_ORANGE="\033[0;33m"
    export COLOR_BLUE="\033[0;34m"
    export COLOR_END="\033[0m"

    SUCCESS="${COLOR_GREEN}${SUCCESS}${COLOR_END}"
    INFO="${COLOR_BLUE}${INFO}${COLOR_END}"
    ERROR="${COLOR_RED}${ERROR}${COLOR_END}"
    WARNING="${COLOR_ORANGE}${WARNING}${COLOR_END}"
  fi
fi

function __print_success() {
  echo -e "[$SUCCESS] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1"
}

function __print_info() {
  echo -e "[$INFO] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1"
}

function __print_error() {
  echo -e "[$ERROR] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1" >&2
}

function __print_warning() {
  echo -e "[$WARNING] ${BASH_SOURCE[-1]##*/}:${BASH_LINENO[0]} $1" >&2
}

set -o pipefail

if [[ $# -eq 0 ]]; then
  __print_error "Missing arguments"
  exit 1
fi

function _rotate_log_file() {
  local log_file="$1"

  # Do nothing if the log file doesn't exist or is empty
  if [[ ! -s "$log_file" ]]; then
    return
  fi

  # Create a timestamp for the new log file
  local timestamp
  timestamp=$(date +"%Y-%m-%dT%H:%M:%S")

  # Construct the new filename
  local rotated_log_file="${log_file%.log}.${timestamp}.log"

  if mv "$log_file" "$rotated_log_file"; then
    __print_success "Rotated log file $log_file to $rotated_log_file"
  else
    __print_error "Failed to rotate log file $log_file to $rotated_log_file"
    return 1
  fi

  return 0
}

function _enable_upnp() {
  local output

  __print_info "Enabling UPnP..."

  # Check if UPnP ports array is set and not empty
  # This prevents command failures when the array is unset or empty
  if [[ -z "${instance_upnp_ports[*]:-}" ]]; then
    __print_error "No UPnP ports configured (instance_upnp_ports is empty or unset)"
    return 1
  fi

  if ! output=$(upnpc -e "$instance_name" -r "${instance_upnp_ports[@]}" 2>&1); then
    __print_error "Failed to enable UPnP ports"
    __print_error "To stop these messages, set 'enable_port_forwarding' to 'false' in $CONFIG_FILE"
    __print_error "${output}"
    return 1
  fi

  # Mark UPnP as enabled
  touch "$UPNP_STATE_FILE"
  __print_success "UPnP enabled"
}

function _disable_upnp() {
  local output

  __print_info "Disabling UPnP..."

  # Check if UPnP ports array is set and not empty
  # This prevents command failures when the array is unset or empty
  if [[ -z "${instance_upnp_ports[*]:-}" ]]; then
    __print_error "No UPnP ports configured (instance_upnp_ports is empty or unset)"
    return 1
  fi

  if ! output=$(upnpc -f "${instance_upnp_ports[@]}" 2>&1); then
    __print_error "Failed to disable UPnP ports"
    __print_error "To stop these messages, set 'enable_port_forwarding' to 'false' in $CONFIG_FILE"
    __print_error "${output}"
    return 1
  fi

  # Mark UPnP as disabled
  rm -f "$UPNP_STATE_FILE"
  __print_success "UPnP disabled"
}

# Helper function to check if UPnP is currently enabled
function _is_upnp_enabled() {
  [[ -f "$UPNP_STATE_FILE" ]]
}

# This function is called when the script is interrupted
# It will disable UPnP if it was enabled and the instance is not running
function _term_cleanup() {
  # We only disable UPnP if ALL of the following conditions are true:
  # 1. A UPnP state file exists, indicating we enabled it at some point.
  # 2. The instance is configured to use port forwarding.
  # 3. The instance is confirmed to be NOT RUNNING.
  if [[ -f "$UPNP_STATE_FILE" ]] && \
     [[ "${instance_enable_port_forwarding:-false}" == "true" ]] && \
     ! _is_active &>/dev/null; then

    # All conditions met, it's safe to disable UPnP.
    _disable_upnp
  fi

  _exit_print_logs
}

trap _term_cleanup INT TERM EXIT

# Start the server in the current terminal
function _start() {
  __print_info "Starting $self in the current terminal"

  if [[ "$instance_enable_port_forwarding" == "true" ]]; then
    if ! _enable_upnp; then
      __print_warning "Failed to enable UPnP, continuing without port forwarding"
    fi
  fi

  if [[ "$instance_auto_update" == "true" ]]; then
    if ! _update; then
      __print_error "Failed to update $self, exiting"
      return 1
    fi
  fi

  cd "$instance_launch_dir" || {
    __print_error "Failed to move into $instance_launch_dir, exiting"
    return 1
  }

  # shellcheck disable=SC2086
  exec $instance_executable_file $instance_executable_arguments
}

# Start the server in the background
# This function will create a named pipe for communication with the server
# and redirect logs to a file. Fixed to eliminate race condition in PID tracking
function _start_background() {
  __print_info "Starting $self in the background"

  # Rotate the latest log file
  if ! _rotate_log_file "$LATEST_LOG_FILE"; then
    __print_error "Failed to rotate latest log file. Aborting to prevent data loss."
    return 1
  fi

  if [[ "$instance_enable_port_forwarding" == "true" ]]; then
    if ! _enable_upnp; then
      __print_warning "Failed to enable UPnP, continuing without port forwarding"
    fi
  fi

  # Handle auto-update before changing directory
  if [[ "$instance_auto_update" == "true" ]]; then
    if ! _update; then
      __print_error "Failed to update $self, exiting"
      return 1
    fi
  fi

  cd "$instance_launch_dir" || {
    __print_error "Failed to move into $instance_launch_dir, exiting"
    return 1
  }

  # Clean up any existing socket file
  [[ -p "$instance_socket_file" ]] && rm "$instance_socket_file"

  # Create named pipe for command input
  mkfifo "$instance_socket_file"

  # Start the server directly with proper I/O redirection
  # This eliminates the subshell race condition while maintaining socket functionality
  # stdin: redirected from socket for command input
  # stdout/stderr: redirected to logs
  # shellcheck disable=SC2086
  $instance_executable_file $instance_executable_arguments \
    <"$instance_socket_file" \
    &>"$instance_logs_redirect" &

  # Capture the actual server process PID (not a subshell)
  local server_pid=$!

  # Validate that we got a valid PID
  if [[ -z "$server_pid" ]] || [[ ! "$server_pid" =~ ^[0-9]+$ ]]; then
    __print_error "Failed to start server process - invalid PID: '$server_pid'"
    [[ -p "$instance_socket_file" ]] && rm -f "$instance_socket_file"
    return 1
  fi

  # Verify the process actually started
  if ! kill -0 "$server_pid" 2>/dev/null; then
    __print_error "Server process failed to start or exited immediately"
    [[ -p "$instance_socket_file" ]] && rm -f "$instance_socket_file"
    return 1
  fi

  # Save the server PID to file
  echo "$server_pid" >"$instance_pid_file"
  __print_success "Instance $instance_name started with PID $server_pid, saved to $instance_pid_file"

  # Prevent EOF on fifo by keeping the named pipe open with a dummy writer
  # This ensures the server doesn't exit when no input is being sent
  tail -f /dev/null >"$instance_socket_file" &
  local tail_pid=$!

  # Validate tail process started successfully
  if [[ -z "$tail_pid" ]] || [[ ! "$tail_pid" =~ ^[0-9]+$ ]] || ! kill -0 "$tail_pid" 2>/dev/null; then
    __print_error "Failed to start socket keepalive process"
    # Try to clean up the server process we just started
    kill -TERM "$server_pid" 2>/dev/null
    [[ -p "$instance_socket_file" ]] && rm -f "$instance_socket_file"
    [[ -f "$instance_pid_file" ]] && rm -f "$instance_pid_file"
    return 1
  fi

  echo "$tail_pid" >"$instance_tail_pid_file"
}

# Kill the server process and all its children
# This function will also remove the PID file and the named pipe
# Fixed to prevent race conditions and properly handle child process arrays
function _kill_all_processes() {
  local tail_pid
  local server_pid
  local output
  local child_pids_string
  local child_pids_array

  # Kill the tail process using atomic read to avoid TOCTOU
  if tail_pid=$(<"$instance_tail_pid_file" 2>/dev/null) && [[ -n "${tail_pid// /}" ]] && [[ "$tail_pid" =~ ^[0-9]+$ ]]; then
    if kill -0 "$tail_pid" 2>/dev/null; then
      kill -TERM "$tail_pid"
      rm -f "$instance_tail_pid_file"
    fi
  fi

  # Atomic read of PID file to avoid TOCTOU vulnerability
  if ! server_pid=$(<"$instance_pid_file" 2>/dev/null); then
    __print_error "No PID file found for $instance_name."
    __print_error "If this is unexpected, check running processes to ensure the instance is not running uncontrolled"
    return 1
  fi

  # Validate that PID is numeric
  if [[ -z "${server_pid// /}" ]] || [[ ! "$server_pid" =~ ^[0-9]+$ ]]; then
    __print_error "Invalid PID in file: '$server_pid'"
    rm -f "$instance_pid_file"
    return 1
  fi

  # Find all child processes of the server PID
  child_pids_string=$(pgrep -P "$server_pid" 2>/dev/null)

  # Convert child PIDs string to proper array for safe processing
  if [[ -n "$child_pids_string" ]]; then
    # Read PIDs into array, one per line
    IFS=$'\n' read -d '' -ra child_pids_array <<<"$child_pids_string" || true

    # Kill child processes if any exist
    if [[ ${#child_pids_array[@]} -gt 0 ]]; then
      if ! output=$(kill -TERM "${child_pids_array[@]}" 2>&1); then
        __print_error "Failed to kill child PIDs: ${child_pids_array[*]}"
        __print_error "Output: ${output}"
        return 1
      fi
      __print_info "Killed ${#child_pids_array[@]} child processes"
    fi
  fi

  # Kill the main server process if it's still running
  if kill -0 "$server_pid" 2>/dev/null; then
    if ! output=$(kill -TERM "$server_pid" 2>&1); then
      __print_error "Failed to kill main process PID $server_pid."
      __print_error "Output: ${output}"
      return 1
    fi
    __print_info "Killed main process PID $server_pid"
  fi
}

# Stop the server gracefully or forcefully
# This function will also save the game state if requested
# and remove the PID file and the named pipe
function _stop_server() {
  local no_save=0
  local no_graceful=0

  __print_info "Stopping $self"

  if ! _is_active &>/dev/null; then
    __print_error "Instance '$instance_name' is not running"
    return 0
  fi

  # Process arguments without destroying them
  local arg
  for arg in "$@"; do
    case "$arg" in
    --no-save) no_save=1 ;;
    --no-graceful) no_graceful=1 ;;
      # Skip the special argument passed in some cases
    "\@") continue ;;
    *) continue ;;
    esac
  done

  if [[ ! "$no_save" ]]; then
    _send_save_command
  fi

  if [[ ! "$no_graceful" ]]; then
    # Send stop command to socket
    if [[ -p "$instance_socket_file" ]]; then
      if [[ -n "$instance_stop_command" ]]; then
        echo "$instance_stop_command" >"$instance_socket_file"
      fi
    fi
  fi

  _kill_all_processes

  [[ -f "$instance_pid_file" ]] && rm -f "$instance_pid_file"
  [[ -p "$instance_socket_file" ]] && rm -f "$instance_socket_file"
  [[ -f "$instance_tail_pid_file" ]] && rm -f "$instance_tail_pid_file"

  if [[ "$instance_enable_port_forwarding" == "true" ]]; then
    _disable_upnp
  fi

  __print_success "Instance '$instance_name' stopped"
}

# This function is used to stop the server gracefully with a timeout
# If the server does not stop within the timeout, it will be killed forcefully
function _timed_stop() {
  local no_save=$1
  local no_graceful=$2

  # UPnP can take a few seconds, so to avoid preemptive timeout we wait longer
  if ! timeout "$instance_stop_command_timeout_seconds" "$0" --internal-stop ${no_save:+--no-save} ${no_graceful:+--no-graceful} $debug; then
    __print_error "Timeout reached, killing instance"
    exec "$0" --kill $debug
  fi
}

# This function is used to save the game state
# It will send the save command to the server through the named pipe
function _send_save_command() {
  # Check if socket file exists and is a named pipe
  if [[ -p "${instance_socket_file}" ]]; then
    # Check if save command is defined
    if [[ -n "${instance_save_command}" ]]; then
      echo "${instance_save_command}" >>"${instance_socket_file}"
      # Sleep to give the server time to process the save command
      sleep "${instance_save_command_timeout_seconds:-5}"
      return 0
    fi
  else
    __print_error "Save failed: No active server found or socket file missing."
    return 1
  fi
}

# This function is used to send input commands to the server through
# the named pipe
function _send_input() {
  if [[ -p "$instance_socket_file" ]]; then
    echo "$1" >>"$instance_socket_file"
  else
    __print_error "Input failed: No active server found."
    return 1
  fi
}

# This function checks if the server is active by checking the PID file
# and verifying if the process with that PID is still running
# Fixed to prevent race conditions using atomic file operations
function _is_active() {
  local server_pid

  # Atomic read operation: attempt to read PID file content directly
  # This eliminates the TOCTOU (Time of Check, Time of Use) vulnerability
  # where the file could be modified between checking existence and reading
  if ! server_pid=$(<"$instance_pid_file" 2>/dev/null); then
    # File doesn't exist, is unreadable, or read failed
    __print_info "Inactive" && return 1
  fi

  # Check if PID file content is empty or contains only whitespace
  if [[ -z "${server_pid// /}" ]]; then
    __print_error "Instance PID file present but empty, removing"
    # Safe removal: only remove if file still exists and is empty
    if [[ -f "$instance_pid_file" ]] && [[ ! -s "$instance_pid_file" ]]; then
      rm -f "$instance_pid_file"
    fi
    __print_info "Inactive" && return 1
  fi

  # Validate that PID is numeric to prevent injection attacks
  if [[ ! "$server_pid" =~ ^[0-9]+$ ]]; then
    __print_error "Instance PID file contains invalid PID: '$server_pid', removing"
    rm -f "$instance_pid_file"
    __print_info "Inactive" && return 1
  fi

  # Check if the process with that PID is running
  # Using kill -0 which doesn't actually send a signal, just checks existence
  if kill -0 "$server_pid" 2>/dev/null; then
    __print_info "Active" && return 0
  else
    # Process is not running anymore, remove stale PID file
    __print_error "Instance PID file references non-existent process (PID: $server_pid), removing"
    rm -f "$instance_pid_file"
    __print_info "Inactive" && return 1
  fi
}

# For closing the log reader background process
# Fixed to prevent race conditions using atomic file operations
# shellcheck disable=SC2317
function _exit_print_logs() {
  local tail_pid

  # Check if the tail PID file exists before trying to read it
  # This prevents shell error messages when the file doesn't exist
  if [[ ! -f "$instance_tail_pid_file" ]]; then
    # File doesn't exist - this is normal during instance creation and other operations
    return 0
  fi

  # Atomic read operation: attempt to read tail PID file content directly
  # This eliminates the TOCTOU vulnerability similar to _is_active()
  if ! tail_pid=$(<"$instance_tail_pid_file" 2>/dev/null); then
    # File exists but is unreadable or read failed
    __print_error "Instance tail PID file exists but is unreadable, removing"
    rm -f "$instance_tail_pid_file"
    return 0
  fi

  # Check if tail PID file content is empty or contains only whitespace
  if [[ -z "${tail_pid// /}" ]]; then
    __print_error "Instance tail PID file present but empty, removing"
    # Safe removal: only remove if file still exists and is empty
    if [[ -f "$instance_tail_pid_file" ]] && [[ ! -s "$instance_tail_pid_file" ]]; then
      rm -f "$instance_tail_pid_file"
    fi
    return 0
  fi

  # Validate that PID is numeric to prevent injection attacks
  if [[ ! "$tail_pid" =~ ^[0-9]+$ ]]; then
    __print_error "Instance tail PID file contains invalid PID: '$tail_pid', removing"
    rm -f "$instance_tail_pid_file"
    return 0
  fi

  # Check if the tail process is still running and kill it if so
  if kill -0 "$tail_pid" 2>/dev/null; then
    __print_info "Stopping log reader..."
    kill "$tail_pid"
    rm -f "$instance_tail_pid_file"
    return 0
  fi

  # Process is not running anymore, remove stale PID file
  __print_error "Instance tail PID file references non-existent process (PID: $tail_pid), removing"
  rm -f "$instance_tail_pid_file"
  return 0
}

function _print_logs() {
  local follow=${1:-false}
  local line_count=${2:-10}

  local log_file_to_follow="$LATEST_LOG_FILE"

  if [[ ! -f "$log_file_to_follow" ]]; then
    __print_info "No log file found at '$log_file_to_follow'"
    return 0
  fi

  if [[ "$follow" == "true" ]]; then
    tail -n "$line_count" -F "$log_file_to_follow"
  else
    tail -n "$line_count" "$log_file_to_follow"
  fi
}

function _update() {

  __print_info "Starting update..."

  # Check if the instance is active
  if _is_active &>/dev/null; then
    __print_error "$self is currently running, please shut down before attempting to update"
    return 1
  fi

  # Get the latest version from remote
  local latest_version
  latest_version=$(_get_latest_version)

  if [[ -z "$latest_version" ]]; then
    __print_error "Failed to retrieve latest version, exiting"
    return 1
  fi

  # Compare versions and save the latest version if different
  local installed_version
  installed_version=$(_get_installed_version)

  if [[ "$latest_version" == "$installed_version" ]]; then
    __print_info "Local version is already up-to-date"
    return 0
  fi

  # Download the latest version
  if ! _download_wrapper "$latest_version"; then
    __print_error "Failed to download latest version $latest_version"
    return 1
  fi

  # Deploy the downloaded files
  if ! _deploy_wrapper; then
    __print_error "Failed to deploy new files"
    return 1
  fi

  # Save the new version to file
  if ! _save_version "$latest_version"; then
    __print_error "Failed to save new version $latest_version to file"
    return 1
  fi

  __print_success "Update complete, new version: $latest_version"

  return 0
}

function _create_backup() {
  __print_info "Creating backup..."

  # Check if install directory exists
  if [[ ! -d "${instance_install_dir}" ]]; then
    __print_error "Install directory ${instance_install_dir} does not exist"
    return 1
  fi

  # Check for content inside the install directory before attempting to
  # create a backup. If empty, skip
  if [ -z "$(ls -A "${instance_install_dir}")" ]; then
    # Source directory is empty, nothing to back up
    __print_warning "${instance_install_dir} is empty, skipping backup"
    return 0
  fi

  # Check instance running state before attempting to create backup
  if _is_active &>/dev/null; then
    __print_error "$self is currently running, please shut down before attempting to create a backup"
    return 1
  fi

  # Ensure backup directory exists
  if [[ ! -d "${instance_backups_dir}" ]]; then
    mkdir -p "${instance_backups_dir}" || {
      __print_error "Failed to create backup directory ${instance_backups_dir}"
      return 1
    }
  fi

  # Format current datetime for backup filename
  local datetime
  datetime="$(date +"%Y-%m-%dT%H:%M:%S")"
  local installed_version
  installed_version=$(_get_installed_version)
  local output="${instance_backups_dir}/${instance_name}-${installed_version:-unknown}-${datetime}.backup"

  if [[ "$instance_compress_backups" == "true" ]]; then
    output="${output}.tar.gz"

    if ! touch "$output"; then
      __print_error "Failed to create $output"
      return 1
    fi

    cd "$instance_install_dir" || return 1

    if ! tar -czf "$output" .; then
      __print_error "Failed to compress $output"
      return 1
    fi
  else
    # Create backup folder if it doesn't exist
    if [ ! -d "$output" ]; then
      if ! mkdir -p "$output"; then
        __print_error "Error creating backup folder $output"
        return 1
      fi
    fi

    # Copy everything from the install directory into a backup folder
    if ! cp -r "$instance_install_dir"/* "$output"/; then
      __print_error "Failed to create backup $output"
      rm -rf "${output:?}"
      return 1
    fi
  fi

  __print_success "Backup created"
  return 0
}

function _restore_backup() {
  local source="$instance_backups_dir/$1"
  local backup_version

  __print_info "Restoring ${source}..."

  if [[ ! -f "$source" ]] && [[ ! -d "$source" ]]; then
    __print_error "Could not find backup $source"
    return 1
  fi

  # Get version number from $source with robust parsing and fallback
  local backup_filename="${source#"$instance_backups_dir/"}"
  local backup_version="unknown"

  # Try to parse version from filename format: instance-version-datetime.backup
  if [[ "$backup_filename" =~ ^[^-]+-([^-]+)-[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.backup ]]; then
    # Extract version from regex match
    backup_version="${BASH_REMATCH[1]}"
    __print_info "Parsed version from backup filename: $backup_version"
  else
    # Fallback: try the original array-based parsing with bounds checking
    IFS='-' read -ra backup_name <<<"$backup_filename"
    if [[ ${#backup_name[@]} -ge 3 ]] && [[ -n "${backup_name[2]}" ]]; then
      backup_version="${backup_name[2]}"
      __print_info "Parsed version using array method: $backup_version"
    else
      # Final fallback: try to extract any version-like pattern from filename
      if [[ "$backup_filename" =~ ([0-9]+\.[0-9]+(\.[0-9]+)?) ]]; then
        backup_version="${BASH_REMATCH[1]}"
        __print_info "Extracted version pattern from filename: $backup_version"
      else
        __print_warning "Could not parse version from backup filename, using 'unknown'"
        backup_version="unknown"
      fi
    fi
    unset IFS
  fi

  if [ -n "$(ls -A "$instance_install_dir")" ]; then
    # $instance_install_dir is not empty, create new backup before proceeding

    __print_warning "Current installation directory is not empty, creating a backup first..."

    # Create backup and verify it succeeded
    if ! _create_backup; then
      __print_error "Failed to create backup before restore. Aborting to prevent data loss."
      return 1
    fi

    # Verify backup was actually created and is accessible
    local latest_backup
    latest_backup=$(ls -t "$instance_backups_dir" | head -1 2>/dev/null)
    if [[ -z "$latest_backup" ]] || [[ ! -e "$instance_backups_dir/$latest_backup" ]]; then
      __print_error "Backup creation appeared to succeed but backup file is not accessible. Aborting to prevent data loss."
      return 1
    fi

    __print_info "Backup created successfully: $latest_backup"

    # Now safe to proceed with destructive operations
    if ! rm -rf "${instance_install_dir:?}"/*; then
      __print_error "Failed to clear $instance_install_dir, exiting"
      return 1
    fi
  fi

  if [[ "$source" == *.gz ]]; then
    cd "$instance_install_dir" || return 1

    if ! tar -xzf "$source" .; then
      __print_error "Failed to restore $source"
      return 1
    fi
  else
    # $instance_install_dir is empty/user confirmed continue, move the backup into it
    if ! cp -r "$source"/* "$instance_install_dir"/; then
      __print_error "Failed to restore backup $source"
      return 1
    fi
  fi

  # Update instance version file with $backup_version
  _save_version "$backup_version" || {
    __print_error "Failed to save restored version $backup_version to file."
    return 1
  }

  __print_success "Restore complete"
  return 0
}

function _list_backups() {
  shopt -s extglob nullglob

  # Create array with contents of the backup dir
  backups_array=("$instance_backups_dir"/*)
  # remove leading $instance_backups_dir:
  backups_array=("${backups_array[@]#"$instance_backups_dir/"}")

  echo "${backups_array[@]}"
}

function _get_installed_version() {
  echo "$(<"$instance_version_file")"
}

function _get_latest_version() {

  # Build login arguments based on authentication requirement
  local login_args="anonymous"
  if [[ "$instance_is_steam_account_required" == "true" ]]; then
    if [[ -z "$STEAM_USERNAME" ]]; then
      __print_error "STEAM_USERNAME is expected but it's not set"
      return 1
    fi

    if [[ -z "$STEAM_PASSWORD" ]]; then
      __print_error "STEAM_PASSWORD is expected but it's not set"
      return 1
    fi

    # Authenticated login: pass username and password as separate arguments
    login_args="$STEAM_USERNAME $STEAM_PASSWORD"
  fi

  local latest_version
  latest_version=$(
    steamcmd \
      +login $login_args \
      +app_info_update 1 \
      +app_info_print $instance_steam_app_id \
      +quit |
      tr '\n' ' ' |
      grep --color=NEVER \
        -Po '"branches"\s*{\s*"public"\s*{\s*"buildid"\s*"\K(\d*)'
  )

  if [[ -z "$latest_version" ]]; then
    __print_error "Failed to retrieve latest version, got empty response from SteamCMD"
    return 1
  fi

  echo "$latest_version"
}

function _compare_versions() {
  local installed_version
  installed_version=$(_get_installed_version)

  local latest_version
  latest_version=$(_get_latest_version)

  if [[ -z "$latest_version" ]]; then
    __print_error "No version information was returned from remote"
    return 1
  fi

  if [[ "$latest_version" == "$installed_version" ]]; then
    __print_info "Local version is the same as remote version"
    return 1
  fi

  echo "$latest_version"
}

function _save_version() {
  local version=$1

  __print_info "Saving version ${version}..."

  echo "$version" >"$instance_version_file"

  __print_success "Version saved"
  return 0
}

function _download() {
  local version=$1
  local dest=${2:-$instance_temp_dir}
  local app_id=${3:-$instance_steam_app_id}

  __print_info "Downloading..."

  # Warn users if they specify a version for Steam games
  if [[ -n "$version" ]] && [[ "$version" != "0" ]] && [[ "$version" != "latest" ]]; then
    __print_warning "Version parameter '$version' will be ignored for Steam games."
    __print_warning "Steam only supports downloading the latest version. For non-Steam games like Factorio or Minecraft, version selection may be supported."
  fi

  if [[ -z "$instance_steam_app_id" ]]; then
    __print_error "'instance_steam_app_id' is expected but it's not set"
    return 1
  fi

  if [[ -z "$instance_is_steam_account_required" ]]; then
    __print_error "'instance_is_steam_account_required' is expected but it's not set"
    return 1
  fi

  # Build login arguments based on authentication requirement
  local login_args="anonymous"
  if [[ $instance_is_steam_account_required -ne 0 ]]; then
    if [[ -z "$STEAM_USERNAME" ]]; then
      __print_error "'STEAM_USERNAME' is expected but it's not set"
      return 1
    fi

    if [[ -z "$STEAM_PASSWORD" ]]; then
      __print_error "'STEAM_PASSWORD' is expected but it's not set"
      return 1
    fi

    # Authenticated login: pass username and password as separate arguments
    login_args="$STEAM_USERNAME $STEAM_PASSWORD"
  fi

  # shellcheck disable=SC2086
  steamcmd \
    +@sSteamCmdForcePlatformType "${instance_platform:-linux}" \
    +force_install_dir "$dest" \
    +login $login_args \
    +app_update "$app_id" \
    validate \
    +quit

  __print_success "Download complete"
  return 0
}

# Wrapper function for download with automatic progress reporting
function _download_wrapper() {
  local version=$1
  local dest=${2:-$instance_temp_dir}
  local app_id=${3:-$instance_steam_app_id}

  __print_info "Starting download process..."

  # Call the actual download function
  if _download "$version" "$dest" "$app_id"; then
    __print_success "Download process completed successfully"
    return 0
  else
    __print_error "Download process failed"
    return 1
  fi
}

function _deploy() {
  local source=$instance_temp_dir
  local dest=$instance_install_dir

  __print_info "Deploying..."

  # Check if $source is empty
  if [[ -z "$(ls -A "$source")" ]]; then
    __print_error "$source is empty, nothing to deploy. Exiting"
    return 1
  fi

  # Copy everything from $source into $dest
  if ! cp -rf "$source"/* "$dest"; then
    __print_error "Failed to copy contents from $source into $dest"
    return 1
  fi

  if ! rm -rf "${source:?}"/*; then
    __print_error "Failed to clear $source"
    return 1
  fi

  __print_success "Deploy complete"
  return 0
}

# Wrapper function for deploy with automatic progress reporting
function _deploy_wrapper() {
  __print_info "Starting deployment process..."

  # Call the actual deploy function
  if _deploy; then
    __print_success "Deployment process completed successfully"
    return 0
  else
    __print_error "Deployment process failed"
    return 1
  fi
}

function _get_status() {
  local json_format="$1"
  local fast_mode="$2"

  # Gather all status information
  local is_active="false"
  local pid=""
  local process_status=""
  local start_time=""
  local current_version=""
  local latest_version=""
  local updates_available="false"
  local disk_usage=""
  local backup_count=""
  local recent_logs=""

  # Check if instance is active
  if _is_active >/dev/null 2>&1; then
    is_active="true"

    # Get process information if active (optimized)
    if [[ -f "$instance_pid_file" ]]; then
      pid=$(cat "$instance_pid_file" 2>/dev/null)
      if [[ -n "$pid" ]] && ps -p "$pid" &>/dev/null; then
        # Get process info in one ps call instead of two
        local ps_output
        ps_output=$(ps -p "$pid" -o state,lstart --no-headers 2>/dev/null)
        if [[ -n "$ps_output" ]]; then
          process_status=$(echo "$ps_output" | awk '{print $1}' | tr -d ' ')
          start_time=$(echo "$ps_output" | awk '{$1=""; print substr($0,2)}')
        fi
      fi
    fi
  fi

  # Get version information (optimized)
  current_version=$(_get_installed_version 2>/dev/null || echo "Unknown")

  if [[ -n "$fast_mode" ]]; then
    latest_version="$current_version"
    updates_available="false"
  else
    # Only check for updates if we have a valid current version
    if [[ "$current_version" != "Unknown" ]]; then
      if _compare_versions >/dev/null 2>&1; then
        latest_version=$(_get_latest_version 2>/dev/null || echo "Unknown")
        updates_available="true"
      else
        latest_version="$current_version"
      fi
    else
      latest_version="$current_version"
    fi
  fi

  # Ultra-fast sequential operations (minimal overhead)
  if [[ -d "$instance_working_dir" ]]; then
    if [[ -n "$fast_mode" ]]; then
      # Use du with --max-depth=0 for fastest accurate size check
      # This avoids recursive traversal and gives actual disk usage
      disk_usage=$(du -sh --max-depth=0 "$instance_working_dir" 2>/dev/null | cut -f1)
    else
      disk_usage=$(du -sh "$instance_working_dir" 2>/dev/null | cut -f1)
    fi
  fi

  # Get backup list using existing function
  local backup_list
  backup_list=$(_list_backups 2>/dev/null)

  # Convert backup list to JSON array
  local backup_json_array="[]"
  if [[ -n "$backup_list" ]]; then
    # Convert space-separated list to JSON array
    backup_json_array=$(printf '%s\n' $backup_list | jq -R . | jq -s .)
  fi

  # Fast logs (minimal processing)
  if [[ -d "$instance_logs_dir" ]]; then
    local latest_log
    latest_log=$(ls -t "$instance_logs_dir" 2>/dev/null | head -1)
    if [[ -n "$latest_log" ]]; then
      recent_logs=$(tail -3 "$instance_logs_dir/$latest_log" 2>/dev/null | jq -R -s . 2>/dev/null || echo '[]')
    else
      recent_logs='[]'
    fi
  else
    recent_logs='[]'
  fi

  if [[ -n "$json_format" ]]; then
    # Output JSON format
    jq -n \
      --arg instance_name "$instance_name" \
      --arg status "$is_active" \
      --arg pid "$pid" \
      --arg process_status "$process_status" \
      --arg start_time "$start_time" \
      --arg current_version "$current_version" \
      --arg latest_version "$latest_version" \
      --arg updates_available "$updates_available" \
      --arg blueprint "$(basename "$instance_blueprint_file")" \
      --arg runtime "$instance_runtime" \
      --arg lifecycle_manager "$instance_lifecycle_manager" \
      --arg directory "$instance_working_dir" \
      --arg ports "${instance_ports:-}" \
      --arg disk_usage "$disk_usage" \
      --argjson backup_list "$backup_json_array" \
      --argjson recent_logs "$recent_logs" \
      '{
        instance_name: $instance_name,
        status: ($status == "true"),
        process: {
          pid: (if $pid != "" then ($pid | tonumber) else null end),
          status: (if $process_status != "" then $process_status else null end),
          start_time: (if $start_time != "" then $start_time else null end)
        },
        version: {
          current: $current_version,
          latest: $latest_version,
          updates_available: ($updates_available == "true")
        },
        configuration: {
          blueprint: $blueprint,
          runtime: $runtime,
          lifecycle_manager: $lifecycle_manager,
          directory: $directory,
          ports: (if $ports != "" then $ports else null end)
        },
        resources: {
          disk_usage: (if $disk_usage != "" then $disk_usage else null end)
        },
        backups: $backup_list,
        recent_logs: $recent_logs
      }'
  else
    # Output human-readable format
    echo "=== Instance Status: $instance_name ==="
    echo -n "Status: "
    if [[ "$is_active" == "true" ]]; then
      echo "✓ Active"
      if [[ -n "$pid" ]]; then
        echo "Process ID: $pid"
        if [[ -n "$process_status" ]]; then
          echo "Process Status: $process_status"
        fi
        if [[ -n "$start_time" ]]; then
          echo "Start Time: $start_time"
        fi
      fi
    else
      echo "✗ Inactive"
    fi

    echo -n "Version: "
    echo "$current_version"

    echo -n "Updates: "
    if [[ -n "$fast_mode" ]]; then
      echo "Skipped (fast mode)"
    elif [[ "$updates_available" == "true" ]]; then
      echo "Available (Latest: $latest_version)"
    else
      echo "Up to date"
    fi

    echo "Blueprint: $(basename "$instance_blueprint_file")"
    echo "Runtime: $instance_runtime"
    echo "Directory: $instance_working_dir"

    if [[ -n "$instance_ports" ]]; then
      echo "Ports: $instance_ports"
    fi

    if [[ -n "$disk_usage" ]]; then
      echo "Disk Usage: $disk_usage"
    fi

    echo "Backups:"
    if [[ -n "$backup_list" ]]; then
      printf '%s\n' $backup_list | sed 's/^/  /'
    else
      echo "  No backups available"
    fi

    echo ""
    echo "Recent Activity:"
    if [[ "$recent_logs" != "[]" ]]; then
      echo "$recent_logs" | jq -r '.[]' | sed 's/^/  /'
    else
      echo "  No recent logs available"
    fi
  fi
}

# Main execution starts here - process command line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
  -h | --help)
    usage && exit 0
    ;;
  --start)
    shift
    if [[ -z "$1" ]]; then
      _start
      exit $?
    fi
    case "$1" in
    --background)
      _start_background
      exit $?
      ;;
    *)
      __print_error "Invalid argument $1"
      exit 1
      ;;
    esac
    ;;
  --stop)
    shift
    # Initialize variables to prevent state pollution
    no_save=0
    no_graceful=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
      --no-save)
        no_save=1
        ;;
      --no-graceful)
        no_graceful=1
        ;;
      *)
        __print_error "Invalid argument $1"
        exit 1
        ;;
      esac
      shift
    done
    _timed_stop "$no_save" "$no_graceful"
    exit $?
    ;;
  --internal-stop)
    shift
    # Initialize variables to prevent state pollution
    no_save=0
    no_graceful=0
    if [[ -z "$1" ]]; then
      _stop_server "\@"
      exit $?
    else
      while [[ $# -gt 0 ]]; do
        case "$1" in
        --no-save)
          no_save=1
          ;;
        --no-graceful)
          no_graceful=1
          ;;
        *)
          __print_error "Invalid argument $1"
          exit 1
          ;;
        esac
        shift
      done
    fi
    _stop_server ${no_save:+--no-save} ${no_graceful:+--no-graceful}
    exit $?
    ;;
  --kill)
    _kill_all_processes
    exit $?
    ;;
  --save)
    _send_save_command
    exit $?
    ;;
  --is-active)
    _is_active
    exit $?
    ;;
  --status)
    shift
    json_format=""
    fast_mode=""

    # Parse status options
    while [[ $# -gt 0 ]]; do
      case "$1" in
      --json)
        json_format="1"
        shift
        ;;
      --fast)
        fast_mode="1"
        shift
        ;;
      *)
        break
        ;;
      esac
    done

    _get_status "$json_format" "$fast_mode"
    exit $?
    ;;
  --input)
    shift
    if [[ -z "$1" ]]; then
      __print_error "Missing argument <command>"
      exit 1
    fi
    _send_input "$1"
    exit $?
    ;;
  --logs)
    shift
    follow="false"
    line_count=10

    while [[ $# -gt 0 ]]; do
      case "$1" in
      -f | --follow)
        follow="true"
        shift
        ;;
      --tail | --lines)
        shift
        if [[ -z "$1" ]] || [[ ! "$1" =~ ^[0-9]+$ ]]; then
          __print_error "Missing or invalid number for --tail/--lines argument"
          exit 1
        fi
        line_count="$1"
        shift
        ;;
      -n)
        shift
        if [[ -z "$1" ]] || [[ ! "$1" =~ ^[0-9]+$ ]]; then
          __print_error "Missing or invalid number for -n argument"
          exit 1
        fi
        line_count="$1"
        shift
        ;;
      *)
        break
        ;;
      esac
    done

    _print_logs "$follow" "$line_count"
    exit $?
    ;;
  --version)
    shift
    if [[ -z "$1" ]]; then
      _get_installed_version
      exit $?
    fi
    case "$1" in
    --compare)
      _compare_versions
      exit $?
      ;;
    --latest)
      _get_latest_version
      exit $?
      ;;
    --save)
      shift
      if [[ -z "$1" ]]; then
        __print_error "Missing argument <version>"
        exit 1
      fi
      _save_version "$1"
      exit $?
      ;;
    *)
      __print_error "Invalid argument $1"
      exit 1
      ;;
    esac
    ;;
  --create-backup)
    _create_backup
    exit $?
    ;;
  --restore-backup)
    shift
    if [[ -z "$1" ]]; then
      __print_error "Missing argument <backup>"
      exit 1
    fi
    _restore_backup "$1"
    exit $?
    ;;
  --list-backups)
    _list_backups
    exit $?
    ;;
  --download)
    version=0
    shift
    if [[ -n "$1" ]]; then
      version="$1"
    fi
    _download_wrapper "$version"
    exit $?
    ;;
  --deploy)
    _deploy_wrapper
    exit $?
    ;;
  --update)
    _update
    exit $?
    ;;
  --enable-upnp)
    _enable_upnp
    exit $?
    ;;
  --disable-upnp)
    _disable_upnp
    exit $?
    ;;
  *)
    __print_error "Unknown argument $1"
    exit 1
    ;;
  esac
  shift
done

exit $?
