#!/usr/bin/env bash

# This file is autogenerated
#
# Modifications done to this file will only affect this game server instance.
# Any changes made to this file will be overwritten if the file is regenerated.
# KGSM will not regenerated this file on its own, but there is a command that
# can be manually used to regenerate the file in case something breaks:
# > $KGSM_ROOT/modules/files.sh --instance <instance> --create --manage

# === BEGIN INJECT CONFIG ===
# === END INJECT CONFIG ===

self=$(basename "$0")
self_path="$(dirname "$(readlink -f "$0")")"

function usage() {
  echo "
Usage:
  $self OPTION

Options:
  -h, --help                Display this help message
  --start                   Start the server in the current terminal
  --start --background      Start the server in the background
  --stop                    Stop the server
    --no-save                 Do not save on shutdown
    --no-graceful             Kill the server process without sending it the
                              stop command.
  --kill                    Kill the server process
  --save                    Save the current game state
  --is-active               Prints if the server is active
  --input <command>         Send an ad-hoc command to the server

  --logs                    Print last 10 lines of the log
  --logs [-f, --follow]     Print live logs
  --enable-upnp             Enable UPnP ports
  --disable-upnp            Disable UPnP ports

  --download                Downloads the game server files

  --list-backups            Print a list of available backups
  --create-backup           Create a backup of the game server files
  --restore-backup <source> Restore a specified backup

  --version                 Print the locally installed version
  --version --save <ver>    Save a given version to file
  --version --latest        Print the latest available version
  --version --compare       Test the local version vs the latest available.
                            If the latest is different, it will be printed to
                            stdout

Examples:
  $self --start --background
  $self --input '/save'
  $self --stop
"
}

INFO="INFO"
ERROR="ERROR"
WARNING="WARNING"

## Colored output
# Check if stdout is tty
if test -t 1; then
  ncolors=0

  # Check for availability of tput
  if command -v tput >/dev/null 2>&1; then
    ncolors="$(tput colors)"
  fi

  # More than 8 means it supports colors
  if [[ $ncolors ]] && [[ "$ncolors" -gt 8 ]]; then
    export COLOR_RED="\033[0;31m"
    export COLOR_GREEN="\033[0;32m"
    export COLOR_ORANGE="\033[0;33m"
    export COLOR_BLUE="\033[0;34m"
    export COLOR_END="\033[0m"

    INFO="${COLOR_BLUE}${INFO}${COLOR_END}"
    ERROR="${COLOR_RED}${ERROR}${COLOR_END}"
    WARNING="${COLOR_ORANGE}${WARNING}${COLOR_END}"
  fi
fi

# shellcheck disable=SC2199
if [[ $@ =~ "--debug" ]]; then
  export PS4='+(\033[0;33m${BASH_SOURCE}:${LINENO}\033[0m): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  set -x
  for a; do
    shift
    case $a in
    --debug) continue ;;
    *) set -- "$@" "$a" ;;
    esac
  done
fi

set -o pipefail

if [[ $# -eq 0 ]]; then
  echo "$self $ERROR: Missing arguments" >&2
  exit 1
fi

function enable_upnp() {
  local output

  echo "$self $INFO: Enabling UPnP..."

  if ! output=$(upnpc -e "$INSTANCE_FULL_NAME" -r "${INSTANCE_UPNP_PORTS[@]}" 2>&1); then
    echo "$self $ERROR: Failed to enable UPnP ports" >&2
    echo "$self $INFO: To stop these message, set USE_UPNP to 0 in $0"
    echo "$self $ERROR: ${output}" >&2
  fi

  echo "$self $INFO: UPnP enabled"
}

function disable_upnp() {
  local output

  echo "$self $INFO: Disabling UPnP..."

  if ! output=$(upnpc -f "${INSTANCE_UPNP_PORTS[@]}" 2>&1); then
    echo "$self $ERROR: Failed to disable UPnP ports" >&2
    echo "$self $INFO: To stop these message, set USE_UPNP to 0 in $0"
    echo "$self $ERROR: ${output}" >&2
  fi

  echo "$self $INFO: UPnP disabled"
}

trap '[[ "$USE_UPNP" -eq 1 ]] && disable_upnp' INT

function start_foreground() {
  if [[ "$INSTANCE_USE_UPNP" -eq 1 ]]; then
    enable_upnp
  fi

  cd "$INSTANCE_LAUNCH_DIR" || {
    echo "$self $ERROR: Failed to move into $INSTANCE_LAUNCH_DIR, exiting" >&2
    return 1
  }

  echo "$self $INFO: Starting ${INSTANCE_FULL_NAME}..."

  exec $INSTANCE_LAUNCH_BIN $INSTANCE_LAUNCH_ARGS
}

function start_background() {
  if [[ "$INSTANCE_USE_UPNP" -eq 1 ]]; then
    enable_upnp
  fi

  cd "$INSTANCE_LAUNCH_DIR" || {
    echo "$self $ERROR: Failed to move into $INSTANCE_LAUNCH_DIR, exiting" >&2
    return 1
  }

  [[ -p "$INSTANCE_SOCKET_FILE" ]] && rm "$INSTANCE_SOCKET_FILE"

  mkfifo "$INSTANCE_SOCKET_FILE"

  $INSTANCE_LAUNCH_BIN $INSTANCE_LAUNCH_ARGS $INSTANCE_LOGS_REDIRECT <"$INSTANCE_SOCKET_FILE" &

  local server_pid=$!
  echo "$server_pid" >"$INSTANCE_PID_FILE"
  echo "$self SUCCESS: Instance $INSTANCE_FULL_NAME started with PID $server_pid, saved to $INSTANCE_PID_FILE"

  # Prevent EOF on fifo by keeping the named pipe open with a dummy writer
  tail -f /dev/null >"$INSTANCE_SOCKET_FILE" &
  echo $! >"$TAIL_PID_FILE"
}

function _kill_all_processes() {

  # Kill the tail process
  if [[ -f "$TAIL_PID_FILE" ]]; then
    local tail_pid
    tail_pid=$(<"$TAIL_PID_FILE")
    if kill -0 "$tail_pid" 2>/dev/null; then
      kill -TERM "$tail_pid"
    fi
  fi

  if [[ ! -f "$INSTANCE_PID_FILE" ]]; then
    echo "$self $ERROR: No PID file found for $INSTANCE_FULL_NAME." >&2
    echo "$self $ERROR: If this is unexpected, check running processes to ensure the instance is not running uncontrolled" >&2
    return 1
  fi

  local server_pid
  server_pid=$(<"$INSTANCE_PID_FILE")

  # Find all child processes of the server PID
  local output
  local child_pids
  child_pids=$(pgrep -P "$server_pid")

  # Instance has child processes
  if [[ -n "$child_pids" ]]; then
    if ! output=$(kill -TERM "${child_pids[@]}"); then
      echo "$self $ERROR: Failed to kill child PIDs ${child_pids[*]}." >&2
      echo "$self $ERROR: Output: ${output}" >&2
      return 1
    fi
  fi

  # Only parent process exists
  if $(is_active &>/dev/null); then
    if ! output=$(kill -TERM "$server_pid" 2>&1); then
      echo "$self $ERROR: Failed to kill PID $server_pid." >&2
      echo "$self $ERROR: Output: ${output}" >&2
      return 1
    fi
  fi
}

function stop_server() {

  if ! $(is_active &>/dev/null); then
    echo "$self $ERROR: Instance $INSTANCE_FULL_NAME is not running" >&2
    return 0
  fi

  for a; do
    shift
    case "$a" in
    --no-save) no_save=1 ;;
    --no-graceful) no_graceful=1 ;;
    *) continue ;;
    esac
  done

  if [[ ! "$no_save" ]]; then
    save_game
  fi

  if [[ ! "$no_graceful" ]]; then
    # Send stop command to socket
    if [[ -p "$INSTANCE_SOCKET_FILE" ]]; then
      if [[ -n "$INSTANCE_STOP_COMMAND" ]]; then
        echo "$INSTANCE_STOP_COMMAND" >"$INSTANCE_SOCKET_FILE"
      fi
    fi
  fi

  _kill_all_processes

  [[ -f "$INSTANCE_PID_FILE" ]] && rm -f "$INSTANCE_PID_FILE"
  [[ -p "$INSTANCE_SOCKET_FILE" ]] && rm -f "$INSTANCE_SOCKET_FILE"
  [[ -f "$TAIL_PID_FILE" ]] && rm -f "$TAIL_PID_FILE"

  if [[ "$INSTANCE_USE_UPNP" -eq 1 ]]; then
    disable_upnp
  fi

  echo "$self SUCCESS: Instance $INSTANCE_FULL_NAME stopped"
}

function timed_stop() {
  local no_save=$1
  local no_graceful=$2

  # UPnP can take a few seconds, so to avoid preemptive timeout we wait longer
  if ! timeout "$INSTANCE_STOP_COMMAND_TIMEOUT_S" "$0" --internal-stop ${no_save:+--no-save} ${no_graceful:+--no-graceful} $debug; then
    echo "$self $ERROR: Timeout reached, killing instance" >&2
    exec "$0" --kill $debug
  fi
}

function save_game() {
  if [[ -p "$INSTANCE_SOCKET_FILE" ]]; then
    if [[ -n "$INSTANCE_SAVE_COMMAND" ]]; then
      echo "$INSTANCE_SAVE_COMMAND" >>"$INSTANCE_SOCKET_FILE"
      sleep "$INSTANCE_SAVE_COMMAND_TIMEOUT_S"
    fi
  else
    echo "$self $ERROR: Save failed: No active server found." >&2
    return 1
  fi
}

function send_input() {
  if [[ -p "$INSTANCE_SOCKET_FILE" ]]; then
    echo "$1" >>"$INSTANCE_SOCKET_FILE"
  else
    echo "$self $ERROR: Input failed: No active server found." >&2
    return 1
  fi
}

function is_active() {
  if [[ ! -f "$INSTANCE_PID_FILE" ]]; then
    echo "$self $INFO: Inactive" && return 1
  fi

  local server_pid
  server_pid=$(<"$INSTANCE_PID_FILE")

  if [[ -z "$server_pid" ]]; then
    echo "$self $ERROR: Instance PID file present but empty, removing" >&2
    rm -rf "$INSTANCE_PID_FILE"

    echo "$self $INFO: Inactive" && return 1
  fi

  # Just test if a process with that PID exists
  if kill -0 "$server_pid" 2>/dev/null; then
    echo "$self $INFO: Active" && return 0
  fi

  echo "$self $INFO: Inactive" && return 1
}

# For closing the log reader background process
tail_pid=
function _exit_print_logs() {
  if $(pgrep "$tail_pid"); then
    echo "$self $INFO: Stopping log reader..."
    kill "$tail_pid"
  fi
}

trap '_exit_print_logs' TERM EXIT INT

function print_logs() {
  local follow=${1:-}
  local latest_log_file

  if ! command -v inotifywait &>/dev/null; then
    echo "$self $ERROR: inotifywait is required to read logs, please install it" >&2
    return 1
  fi

  # Without follow, just print the last few lines of the latest file
  if [[ -z "$follow" ]]; then

    latest_log_file="$(ls -t "$INSTANCE_LOGS_DIR" | head -1)"

    if [[ -z "$latest_log_file" ]]; then
      echo "$self $INFO: No log files found"
      return 0
    fi

    tail "$latest_log_file"
    return $?

  # With follow, keep the logs live even through file changes
  else
    while true; do
      latest_log_file="$(ls -t "$INSTANCE_LOGS_DIR" | head -1)"

      # This is busy waiting, but don't have a better solution atm.
      if [[ -z "$latest_log_file" ]]; then
        sleep 2
        continue
      fi

      echo "$self $INFO: Following logs from $latest_log_file"

      tail -F "$INSTANCE_LOGS_DIR/$latest_log_file" &
      tail_pid=$!

      # Wait for tail process to finish or the log file to be replaced
      inotifywait -e create -e moved_to "$INSTANCE_LOGS_DIR"

      # New log file detected; kill current tail and loop back to follow the new file
      kill "$tail_pid"
      echo "$self $INFO: Detected new log file. Switching to the latest log..."
      sleep 1
    done
  fi
}

# === INJECT UPDATE ===

function _create_backup() {

  echo "$self $INFO: Creating backup..."

  # Check for content inside the install directory before attempting to
  # create a backup. If empty, skip
  if [ -z "$(ls -A "$INSTANCE_INSTALL_DIR")" ]; then
    # $source is empty, nothing to back up
    echo "$self $ERROR: $INSTANCE_INSTALL_DIR is empty, skipping backup" >&2
    return 0
  fi

  # Check instance running state before attempting to create backup
  if is_active &>/dev/null; then
    echo "$self $ERROR: $self is currently running, please shut down before attempting to create a backup" >&2
    return 1
  fi

  #shellcheck disable=SC2155
  local datetime="$(date +"%Y-%m-%dT%H:%M:%S")"
  local output="${INSTANCE_BACKUPS_DIR}/${INSTANCE_FULL_NAME}-${INSTANCE_INSTALLED_VERSION}-${datetime}.backup"

  if [[ "$INSTANCE_COMPRESS_BACKUPS" == 1 ]]; then
    output="${output}.tar.gz"

    if ! touch "$output"; then
      echo "$self $ERROR: Failed to create $output" >&2
      return 1
    fi

    cd "$INSTANCE_INSTALL_DIR" || return 1

    if ! tar -czf "$output" .; then
      echo "$self $ERROR: Failed to compress $output" >&2
      return 1
    fi
  else
    # Create backup folder if it doesn't exit
    if [ ! -d "$output" ]; then
      if ! mkdir -p "$output"; then
        echo "$self $ERROR: Error creating backup folder $output" >&2
        return 1
      fi
    fi

    # Copy everything from the install directory into a backup folder
    if ! cp -r "$INSTANCE_INSTALL_DIR"/* "$output"/; then
      echo "$self $ERROR: Failed to create backup $output" >&2
      rm -rf "${output:?}"
      return 1
    fi
  fi

  # _emit_instance_backup_created "${instance%.ini}" "$output" "$INSTANCE_INSTALLED_VERSION"
  echo "$self $INFO: Backup created"
  return 0
}

function _restore_backup() {
  local source="$INSTANCE_BACKUPS_DIR/$1"
  local backup_version

  echo "$self $INFO: Restoring ${source}..."

  if [[ ! -f "$source" ]] && [[ ! -d "$source" ]]; then
    echo "$self $ERROR: Could not find backup $source" >&2
    return 1
  fi

  # Get version number from $source
  IFS='-' read -ra backup_name <<<"${source#"$INSTANCE_BACKUPS_DIR/"}"
  backup_version="${backup_name[2]}"
  unset IFS

  if [ -n "$(ls -A "$INSTANCE_INSTALL_DIR")" ]; then
    # $INSTANCE_INSTALL_DIR is not empty, create new backup before proceeding

    echo "$self $WARNING: Current installation directory is not empty, creating a backup first..."

    _create_backup || {
      local create_backup_exit_code=$?
      echo "$self $ERROR: Failed to restore backup ${source#"$INSTANCE_BACKUPS_DIR/"}" >&2
      return $create_backup_exit_code
    }

    if ! rm -rf "${INSTANCE_INSTALL_DIR:?}"/*; then
      echo "$self $ERROR: Failed to clear $INSTANCE_INSTALL_DIR, exiting" >&2
      return 1
    fi
  fi

  if [[ "$source" == *.gz ]]; then
    cd "$INSTANCE_INSTALL_DIR" || return 1

    if ! tar -xzf "$source" .; then
      echo "$self $ERROR: Failed to restore $source" >&2
      return 1
    fi
  else
    # $INSTANCE_INSTALL_DIR is empty/user confirmed continue, move the backup into it
    if ! cp -r "$source"/* "$INSTANCE_INSTALL_DIR"/; then
      echo "$self $ERROR: Failed to restore backup $source" >&2
      return 1
    fi
  fi

  # Update instance version file with $backup_version
  _save_version "$backup_version" || {
    echo "$self $ERROR: Failed to save restored version $backup_version to file." >&2
    return 1
  }

  # __emit_instance_backup_restored "${instance%.ini}" "$source" "$backup_version"
  echo "$self $INFO: Restore complete"
  return 0
}

function _list_backups() {
  shopt -s extglob nullglob

  # Create array with contents of the backup dir
  backups_array=("$INSTANCE_BACKUPS_DIR"/*)
  # remove leading $instance_backups_dir:
  backups_array=("${backups_array[@]#"$INSTANCE_BACKUPS_DIR/"}")

  echo "${backups_array[@]}"
}

function _get_installed_version() {
  echo "$(<"$INSTANCE_VERSION_FILE")"
}

function _get_latest_version() {

  app_id=$INSTANCE_APP_ID

  username=anonymous
  auth_level=$INSTANCE_STEAM_ACCOUNT_NEEDED

  if [[ $auth_level -ne 0 ]]; then
    if [[ -z "$STEAM_USERNAME" ]]; then
      echo "$self $ERROR: STEAM_USERNAME is expected but it's not set" >&2
      return 1
    fi

    if [[ -z "$STEAM_PASSWORD" ]]; then
      echo "$self $ERROR: STEAM_PASSWORD is expected but it's not set" >&2
      return 1
    fi

    username="$STEAM_USERNAME $STEAM_PASSWORD"
  fi

  local latest_version
  latest_version=$(
    steamcmd \
      +login $username \
      +app_info_update 1 \
      +app_info_print $app_id \
      +quit |
      tr '\n' ' ' |
      grep --color=NEVER \
        -Po '"branches"\s*{\s*"public"\s*{\s*"buildid"\s*"\K(\d*)'
  )

  if [[ -z "$latest_version" ]]; then
    echo "$self $ERROR: Failed to retrieve latest version, got empty response from SteamCMD" >&2
    return 1
  fi

  echo "$latest_version"
}

function _compare_versions() {
  local installed_version
  installed_version=$(_get_installed_version)

  local latest_version
  latest_version=$(_get_latest_version)

  if [[ -z "$latest_version" ]]; then
    echo "$self $ERROR: No version information was returned from remote" >&2
    return 1
  fi

  if [[ "$latest_version" == "$installed_version" ]]; then
    echo "$self $INFO: Local version is the same as remote version"
    return 1
  fi

  echo "$latest_version"
}

function _save_version() {
  local version=$1

  echo "$self $INFO: Saving version ${version}..."

  echo "$version" >"$INSTANCE_VERSION_FILE"

  echo "$self $INFO: Version saved"
  return 0
}

function _download() {
  local version=$1
  local dest=$INSTANCE_TEMP_DIR
  local app_id=$INSTANCE_APP_ID

  echo "$self $INFO: Downloading..."

  if [[ -z "$INSTANCE_APP_ID" ]]; then
    echo "$self $ERROR: INSTANCE_APP_ID is expected but it's not set" >&2
    return 1
  fi

  if [[ -z "$INSTANCE_STEAM_ACCOUNT_NEEDED" ]]; then
    echo "$self $ERROR: INSTANCE_STEAM_ACCOUNT_NEEDED is expected but it's not set" >&2
    return 1
  fi

  username=anonymous
  if [[ $INSTANCE_STEAM_ACCOUNT_NEEDED -ne 0 ]]; then
    if [[ -z "$STEAM_USERNAME" ]]; then
      echo "$self $ERROR: STEAM_USERNAME is expected but it's not set" >&2
      return 1
    fi

    if [[ -z "$STEAM_PASSWORD" ]]; then
      echo "$self $ERROR: STEAM_PASSWORD is expected but it's not set" >&2
      return 1
    fi

    username="$STEAM_USERNAME $STEAM_PASSWORD"
  fi

  steamcmd \
    +@sSteamCmdForcePlatformType linux \
    +force_install_dir "$dest" \
    +login $username \
    +app_update "$app_id" \
    validate \
    +quit

  echo "$self $INFO: Download complete"
  return 0
}

function _deploy() {
  local source=$INSTANCE_TEMP_DIR
  local dest=$INSTANCE_INSTALL_DIR

  echo "$self $INFO: Deploying..."

  # Check if $source is empty
  if [[ -z "$(ls -A "$source")" ]]; then
    echo "$self $ERROR: $source is empty, nothing to deploy. Exiting" >&2
    return 1
  fi

  # Copy everything from $source into $dest
  if ! cp -rf "$source"/* "$dest"; then
    echo "$self $ERROR: Failed to copy contents from $source into $dest" >&2
    return 1
  fi

  if ! rm -rf "${source:?}"/*; then
    echo "$self $ERROR: Failed to clear $source" >&2
    return 1
  fi

  echo "$self $INFO: Deploy complete"
  return 0
}

# Functions to add for standalone management:
# - update

while [[ $# -gt 0 ]]; do
  case "$1" in
  -h | --help)
    usage && exit 0
    ;;
  --start)
    shift
    if [[ -z "$1" ]]; then
      start_foreground
      exit $?
    fi
    case "$1" in
    --background)
      start_background
      ;;
    *)
      echo "$self $ERROR: Invalid argument $1" >&2
      exit 1
      ;;
    esac
    ;;
  --stop)
    shift
    while [[ $# -gt 0 ]]; do
      case "$1" in
      --no-save)
        no_save=1
        ;;
      --no-graceful)
        no_graceful=1
        ;;
      *)
        echo "$self $ERROR: Invalid argument $1" >&2
        exit 1
        ;;
      esac
      shift
    done
    timed_stop "$no_save" "$no_graceful"
    exit $?
    ;;
  --internal-stop)
    shift
    if [[ -z "$1" ]]; then
      stop_server "\@"
      exit $?
    else
      while [[ $# -gt 0 ]]; do
        case "$1" in
        --no-save)
          no_save=1
          ;;
        --no-graceful)
          no_graceful=1
          ;;
        *)
          echo "$self $ERROR: Invalid argument $1" >&2
          exit 1
          ;;
        esac
        shift
      done
    fi
    stop_server ${no_save:+--no-save} ${no_graceful:+--no-graceful}
    ;;
  --kill)
    kill_server
    exit $?
    ;;
  --save)
    save_game
    ;;
  --is-active)
    is_active
    exit $?
    ;;
  --input)
    shift
    if [[ -z "$1" ]]; then
      echo "$self $ERROR: Missing argument <command>" >&2
      exit 1
    fi
    send_input "$1"
    ;;
  --logs)
    follow=false
    shift
    case "$1" in
    -f | --follow)
      follow=true
      ;;
    *)
      echo "$self $ERROR: Invalid argument $1" >&2
      exit 1
      ;;
    esac
    print_logs $follow
    ;;
  --version)
    shift
    if [[ -z "$1" ]]; then
      _get_installed_version
      exit $?
    fi
    case "$1" in
    --compare)
      _compare_versions
      ;;
    --latest)
      _get_latest_version
      ;;
    --save)
      shift
      if [[ -z "$1" ]]; then
        echo "$self $ERROR: Missing argument <version>" >&2
        exit 1
      fi
      _save_version "$1"
      ;;
    *)
      echo "$self $ERROR: Invalid argument $1" >&2
      exit 1
      ;;
    esac
    ;;
  --create-backup)
    _create_backup
    ;;
  --restore-backup)
    _restore_backup "$@"
    ;;
  --list-backups)
    _list_backups
    ;;
  --download)
    _download "$@"
    ;;
  --deploy)
    _deploy
    ;;
  --enable-upnp)
    enable_upnp
    ;;
  --disable-upnp)
    disable_upnp
    ;;
  *)
    echo "$self $ERROR: Unknown argument $1" >&2
    exit 1
    ;;
  esac
  shift
done

exit $?
